<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack</title>
      <link href="/2022/07/05/webpack/"/>
      <url>/2022/07/05/webpack/</url>
      
        <content type="html"><![CDATA[<p>webpack 随手记</p><span id="more"></span><h1 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h1><h2 id="五个核心概念"><a href="#五个核心概念" class="headerlink" title="五个核心概念"></a>五个核心概念</h2><ol><li>Entry(入口)<ul><li>指示 webpack 以哪个文件为入口起点开始打包,分析构建依赖图</li></ul></li><li>Output(出口)<ul><li>指示webpack 打包后资源 bundles 输出到哪里去,以及如何命名</li></ul></li><li>Loader(‘ 翻译 ‘)<ul><li>让 webpack 能够处理那些非 Javascript文件(webpack 自身只理解 Javascript )</li></ul></li><li>Plugins<ul><li>可以用于执行范围更广的任务.插件范围包括:从打包优化和压缩一直到重新定义环境中的变量等</li></ul></li><li>Mode<ol><li>开发模式<ol><li>特点:能让代码本地测试运行的环境</li></ol></li><li>生产模式<ol><li>特点:能让代码优化上线运行的环境</li></ol></li><li><img src="https://s1.ax1x.com/2020/05/31/t33Mo6.png"></li></ol></li></ol><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>指示 webpack 应该使用哪个模块，来作为构建其<strong>内部依赖图</strong> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口七点 依赖的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">entry：&#x27;./src/index.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>告诉webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports =&#123;</span><br><span class="line">output:&#123;</span><br><span class="line">        path: 路径,</span><br><span class="line">        filename: 文件名称</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><strong>webpack 只能理解 JavaScript 和 JSON 文件</strong>，这是webpack开箱可用的自带能力。<strong>loader</strong>让 webpack 能够去处理<strong>其他类型的文件</strong>，并将它们转换为有效 <strong>模块</strong>，以供应应用程序使用，以及被添加到依赖图中。</p><p>将模块内容按照需求转化成新内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack 的其中一个强大的特性就是通过 import 导入任何类型的模块（例如： .css 文件），其他打包程序或人物执行器的可能并不支持。</span><br></pre></td></tr></table></figure><p><strong>loader 有两个属性：</strong></p><ol><li><p><strong>test</strong> 属性，识别出哪些文件会被转换。</p></li><li><p><strong>use</strong> 属性，定义出在进行转换时，应该使用哪个 loader。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">module:&#123;</span><br><span class="line">rules:[&#123;test:/.\txt$/,use:&#x27;raw-loader&#x27;&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p><p>想要使用一个插件，只需要 <strong>require（）</strong>，然后把它添加到 <strong>plugins</strong> 数组中。多数插件可以通过选项（<strong>option</strong>）自定义。也可以在<strong>一个配置文件中因为不同的目的而多次使用同一个插件</strong>，这时需要通过使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 webpack 构建流程中的特定时机会广播出对应的时间，插件可以监听这些事件的发生，在特定时机做对应的事情</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>在webpack里一切皆模块，一个模块对应着一个文件。webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>代码块，一个Chunk 由多个模块组合而成，用于代码合并与分割</p><h1 id="webpack-初体验"><a href="#webpack-初体验" class="headerlink" title="webpack 初体验"></a>webpack 初体验</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli -g | -D(开发依赖)</span><br><span class="line"></span><br><span class="line">开发环境 : webpack ./src/index.js -o  ./build/built.js --mode-development ./src/index.js 为入口文件开始打包,打包后输出到 ./build/built.js  -- 整体打包环境是开发环境</span><br><span class="line">webpack 会以</span><br><span class="line"></span><br><span class="line">生产环境打包 : webpack ./src/index.js -o  ./build/built.js --mode-production</span><br></pre></td></tr></table></figure><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src - index.js 入口文件</span><br><span class="line">build - 打包文件的地方</span><br></pre></td></tr></table></figure><ol><li>webpack 能处理 js &#x2F; json 资源,不能处理 css &#x2F;img 等其他资源</li><li>生产环境比开发环境多一个压缩 js 代码</li><li>生产和开发环境 将ES6模块化编译成浏览器能识别的模块化</li></ol><h2 id="webpack打包资源"><a href="#webpack打包资源" class="headerlink" title="webpack打包资源"></a>webpack打包资源</h2><h3 id="样式打包"><a href="#样式打包" class="headerlink" title="样式打包"></a>样式打包</h3><p>lader必须定义配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">webpack.confug.js -- webpack的配置文件</span><br><span class="line">指示webpack 干什么(当运行 webpack 指令时,会加载里面的配置)</span><br><span class="line">所有的构建工具都是基于 node.js 平台运行的~模块化默认采用 commjs</span><br><span class="line">commjs暴露模式</span><br><span class="line"></span><br><span class="line">resolve用来拼接绝对路径的方法</span><br><span class="line">const &#123;resolve&#125; = require(&#x27;path&#x27;)</span><br><span class="line">const HtmlWebpack = requie</span><br><span class="line">module.exports = &#123;</span><br><span class="line">entry:&#x27;./src/index.js&#x27; ~入口七点</span><br><span class="line">output:&#123;</span><br><span class="line">filename:&quot;&quot; 输出文件名</span><br><span class="line">path: resole(_dirname,&#x27;build&#x27;)~输出路径 / _dirname代表当前文件的目录的绝对路径</span><br><span class="line">&#125;,</span><br><span class="line">module:&#123;</span><br><span class="line">rules:[</span><br><span class="line">详细loader配置</span><br><span class="line">&#123;</span><br><span class="line">                test:/\.css$/,</span><br><span class="line">                //use数组中 loader 执行顺序:从右到左,从上到下,依次执行</span><br><span class="line">                use:[ 使用哪些loader进行处理</span><br><span class="line">                    &#x27;style-loader&#x27;</span><br><span class="line">                    &#x27;css-loader&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; 排除 css html js 文件</span><br><span class="line">exclude:/\.(css|html|js)$/</span><br><span class="line">loader:&#x27;file - loader&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">处理图片资源</span><br><span class="line">&#123;</span><br><span class="line">test:/\.(jpg|png|gif)$/</span><br><span class="line">loader:&#x27;url-loader&#x27;,</span><br><span class="line">options:&#123;</span><br><span class="line">limit:8*1024,</span><br><span class="line">name:&#x27;[hash:10.[ext]]&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//处理html中 img 资源</span><br><span class="line">test:/\.html$/,</span><br><span class="line">loader:&#x27;html-loader&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">详细plugins的配置</span><br><span class="line">new HtmlWebpack(&#123;</span><br><span class="line">template:&#x27;./src/index.html&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">],</span><br><span class="line">模式</span><br><span class="line">mode:&#x27;development&#x27; / &#x27;production&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="devServe"><a href="#devServe" class="headerlink" title="devServe"></a>devServe</h3><p>自动编译,在内存中进行打包,不会有任何输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">contenBase:resolve(_dirname,&#x27;build&#x27;),</span><br><span class="line">//开启压缩</span><br><span class="line">compress:true,</span><br><span class="line">port:3000,</span><br><span class="line">//自动打开浏览器</span><br><span class="line">open:true</span><br><span class="line">&#125;</span><br><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><h1 id="webpack开发环境搭建"><a href="#webpack开发环境搭建" class="headerlink" title="webpack开发环境搭建"></a>webpack开发环境搭建</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">entry:&#x27;&#x27;,</span><br><span class="line">output:&#123;</span><br><span class="line">filename:&#x27;built.js&#x27;</span><br><span class="line">path: </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码的集合就是开发环境搭建</span><br></pre></td></tr></table></figure><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol><li><p>工作原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析项目结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言（Sass、TypeScript等），并将其转换和打包为合适的格式供浏览器使用</span><br></pre></td></tr></table></figure></li><li><p>打包原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一切都视为模块： 不管是 css、js、image 还是 html 都可以互相引用，通过定义 entry.</span><br></pre></td></tr></table></figure></li><li><p>如何提高webpack 构建速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonsChunkPlugin</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/07/05/TypeScript/"/>
      <url>/2022/07/05/TypeScript/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 知识点随手记</p><span id="more"></span><h1 id="认识TS"><a href="#认识TS" class="headerlink" title="认识TS"></a>认识TS</h1><p>是js的一个超集,提供了类型系统和ES6+ 的支持,不能直接被浏览器运行的.ts中的json文件可以写<strong>注释</strong>,默认是严格模式</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>自动编译TS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc --init  项目中的根目录下</span><br><span class="line">修改config.js文件</span><br></pre></td></tr></table></figure><p>使用webpack打包TS</p><p>下载依赖</p><p><img src="https://s1.ax1x.com/2020/06/10/t7m9sI.png"></p><p><strong>cross-env</strong>指定生产环境或开发环境的一个包(包括 windows + linux 系统)</p><p>创建 <strong>webpack.config.js</strong> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV === &#x27;production&#x27; 是否生产环境的一个判断</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="TS的基础数据类型"><a href="#TS的基础数据类型" class="headerlink" title="TS的基础数据类型"></a>TS的基础数据类型</h1><ol><li><p>布尔</p></li><li><p>number</p></li><li><p>string</p></li><li><p>null  undefined</p><ol><li>元素的属性只能是 null + undefined</li></ol></li><li><p>数组</p><ol><li><p>数组的类型</p><ul><li><p>类型+方括号 表示法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let f:number[] = [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li><li><p>数组中<strong>不允许</strong>出现其他的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let f:number[] = [1,2,&quot;1&quot;,3,4]</span><br><span class="line">// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure></li><li><p>数组的一些方法参数会根据数组在定义时约定的类型进行限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let f:number[] = [1,2,3,1,4];</span><br><span class="line">f.push(&#x27;8&#x27;)</span><br><span class="line">// Argument of type &#x27;&quot;8&quot;&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><ul><li>上面数组中定义只允许传入数字类型的参数,传入了’8’(字符串类型),所以报错</li></ul></li></ul></li><li><p>数组的泛型(Array<elemType>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fib:Array&lt;number&gt; = [1,1,2,3,4]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元组(Tuple)</p><ol><li><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let t: [number,string]</span><br><span class="line">t = [1,&#x27;abc&#x27;]</span><br><span class="line">t = [&#x27;abc&#x27;,1] -&gt; 报错 类型不匹配</span><br></pre></td></tr></table></figure></li></ol></li><li><p>枚举</p><ol><li><p>对JavaScript标准数据类型的一个补充,使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">red,</span><br><span class="line">yellow,</span><br><span class="line">blue</span><br><span class="line">&#125;</span><br><span class="line">let color: Color = Color.red</span><br><span class="line">根据名称取对应保存的数值</span><br><span class="line">根据数值读取对应的名称</span><br></pre></td></tr></table></figure></li></ol></li><li><p>any</p><ol><li><p>在编程阶段声明的变量类型是不确定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let notShure :any = 1</span><br></pre></td></tr></table></figure></li><li><p>在数组中的应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用any表示数组中允许出现任意类型</span><br><span class="line">let list:any[] = [&#x27;kevin&#x27;,20,&#123;website:&#x27;http://www.baidu.com&#x27;&#125;]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>void</p><ol><li>与any类型相反,代表函数的返回值只能是 undefined 或者 null</li></ol></li><li><p>Never</p></li><li><p>表示的是那些永不存在的值的类型</p></li><li><p>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。即使 any 也不可以赋值给never</p></li><li><p>object</p><ol><li><p>表示非原始类型,也就是 number,string,boolean 之外的类型</p></li><li><p>使用 object 类型,就可以更好的表示像 Object.creat这样的 API</p></li></ol></li><li><p>联合类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求1:定义一个函数得到一个数字或字符串值的字符串形式值</span><br><span class="line">(()=&gt;&#123;</span><br><span class="line">functon toString</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>类型断言</p></li><li><p>类型推断</p></li></ol><h1 id="TS接口"><a href="#TS接口" class="headerlink" title="TS接口"></a>TS接口</h1><p>TS的核心原则之一是对值所具有的结构进行类型检查.使用接口来定义对象的类型.接口时对象的状态(属性)和行为(方法)的抽象(描述)</p><ol><li><p>接口( <strong>interface</strong> )规范</p><ul><li><p>readonly -&gt; 只读属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readonly id:number  id属性为只读的,不可以进行二次赋值</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数类型的接口</p><ul><li><p>创建一个函数类型的变量并赋值给这个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch:searchFunc</span><br><span class="line">mySearch = function(source:string,subString:string)&#123;</span><br><span class="line">let result source.search(subString);</span><br><span class="line">return result &gt; -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于函数类型的类型检查来说,函数的参数名不需要与接口里定义的名字相匹配</li><li>函数的参数会逐个检查,要求对应位置上的参数类型的兼容,如果不想指定类型,ts类型系统会推断出参数类型.如果让这个函数返回数字或字符串,类型检查器会警告函数的返回值类型与 <strong>SearchFunc</strong> 接口中的定义不匹配</li></ol></li></ul></li></ol><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><ol><li><p>类实现接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface test &#123;</span><br><span class="line">current:Date;</span><br><span class="line">&#125;</span><br><span class="line">class Clock implements test&#123;</span><br><span class="line">current:Date;</span><br><span class="line">setTime(d:Date)&#123;</span><br><span class="line">this.current = d;</span><br><span class="line">&#125;</span><br><span class="line">constructor(h:number,m:number)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类实现继承(<strong>extends</strong>)</p></li><li><p>类的基本定义与使用</p></li><li><p>类的继承_方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">class animal&#123;</span><br><span class="line">run(distance:number)&#123;</span><br><span class="line">console.log(`animal run $&#123;distance&#125;m `)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类</span><br><span class="line">class dog extend animal&#123;</span><br><span class="line">//重写从父类继承的方法</span><br><span class="line">super.run(distance)</span><br><span class="line">&#125;</span><br><span class="line">const dog = new dog()</span><br><span class="line">dog.run(10)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多态_父类型引用指向子类型对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个类只能继承一个单一的类</span><br><span class="line">多态:父类型的引用指向子类型的实例</span><br></pre></td></tr></table></figure></li></ol><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><ol><li><p>类数组不是数组类型,比如 <strong>arguments</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line">let args:number[] = arguments;</span><br><span class="line">&#125;</span><br><span class="line">报错// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span><br></pre></td></tr></table></figure><p>argumen实际上是一个类数组,不能用普通数组的方式来描述,应该使用接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line">let args:&#123;</span><br><span class="line">[index:number]:number;</span><br><span class="line">length:number;</span><br><span class="line">callee:Function;</span><br><span class="line">&#125; = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">a:string;</span><br><span class="line">constructor(message:string)&#123;</span><br><span class="line">this.a = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get()&#123;</span><br><span class="line">return &#x27;hello,&#x27;+ this.a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new test(&#x27;world&#x27;);</span><br><span class="line">console.log(b) // hello,world</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    move(distanceInMeters: number = 0) &#123;</span><br><span class="line">        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        console.log(&#x27;Woof! Woof!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认是 public(公共的)</span><br><span class="line"></span><br><span class="line">private(私有的)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="/2022/07/05/Vue/"/>
      <url>/2022/07/05/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>全家桶：</strong> vue-cli、vueRouter、vuex、axios</p><span id="more"></span><h1 id="Vue核心思想"><a href="#Vue核心思想" class="headerlink" title="Vue核心思想"></a>Vue核心思想</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面拆分</span><br></pre></td></tr></table></figure><hr><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><ol><li><strong>数据驱动是vue双向数据绑定的灵魂</strong><ol><li>当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的修改dom</li></ol></li><li><strong>vuejs实现数据驱动原理</strong><ol><li>采用数据劫持结合<strong>发布者-订阅模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。当把一个普通的js对象传给Vue实例作为他的 data 选项时，Vue会便利它的属性，用<strong>Object.defineProperty（）</strong>将他们转为 getter&#x2F;setter。</li><li>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {undefined{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</li></ol></li><li><strong>对getter&#x2F;setter的理解</strong><ol><li>get取值，set赋值</li><li>如何知道对象的值做了更改？<ol><li>当调用属性时会进入get属性中，先判断是否有这个属性，如果没有就添加一个name属性，并给他赋值；如果有name属性则返回name属性。值的改变都必须经过set，其他方式是改变不了相当于是一个万能的监听器。ES5的对象原型有两个属性_defineGetter_  和 _defineSetter_，专门用来给对象绑定get和ser</li></ol></li></ol></li></ol><p><strong>Object.defineProperty</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  obj,</span><br><span class="line">  key,</span><br><span class="line">  val,</span><br><span class="line">  customSetter,</span><br><span class="line">  shallow</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 创建派发器</span></span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.<span class="property">get</span>;</span><br><span class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.<span class="property">set</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val;</span><br><span class="line">      <span class="comment">// 收集依赖对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>();</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;development&quot;</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal);</span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="MVVM-和-MVC"><a href="#MVVM-和-MVC" class="headerlink" title="MVVM 和 MVC"></a>MVVM 和 MVC</h1><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ol><li><strong>Model：</strong> 指的是数据部分，对应到前端相当于JavaScript对象</li><li><strong>View：</strong> 指的是视图部分，对应前端相当于dom</li><li><strong>ViewModel</strong>： 就是连接视图与数据的中组件通讯</li></ol><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC全名是 Model View Controller,时<strong>模型 - 视图 - 控制器</strong>的缩写，一种<strong>软件设计典范</strong>。</p><ul><li>Model(模型)：是用于处理应用程序数据逻辑部分。通常模型对象负责在数据库中存取数据。</li><li>View(视图)：是应用程序中处理数据显示的本分。通常视图是依据模型数据创建的。</li><li>Controller(控制器)：是应用程序处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p><strong>MVC的思想</strong>：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在<strong>Controller</strong>里面把<strong>Model</strong>的数据赋值给<strong>View</strong>。</p><h3 id="两者之前的区别"><a href="#两者之前的区别" class="headerlink" title="两者之前的区别"></a>两者之前的区别</h3><p>MVVM与MVC最大的区别就是：<strong>实现了View和Model的自动同步</strong>，也就是当Model的属性改变时，我们不用再手动操作Dom元素来改变View的显示。 而是改变属性后该属性对应的View层显示会自动改变（对应Vue数据驱动的思想）</p><p>整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了<strong>数据频繁更新</strong>的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也察觉不到View，这种低耦合模式提高代码的可重用性。</p><p><strong>注意</strong>：Vue并没有完全遵循MVVM的思想，这一点官网自己也有声明。</p><hr><h1 id="Vue-2-0响应式数据的原理"><a href="#Vue-2-0响应式数据的原理" class="headerlink" title="Vue 2.0响应式数据的原理"></a>Vue 2.0响应式数据的原理</h1><p><strong>整体思路：</strong> 数据劫持+观察者模式</p><p>对象内部通过 defineReactive 方法，使用Object.defineProoperty将属性进行劫持（置灰劫持已存在的属性），数组则是通过重写数组来实现。当页面谁用对应属性时，每个属性都拥有自己的 dep 属性，存在它所以来的 watch （依赖收集） get，当属性变化后会通知自己对应的 watcher 去更新（派发更新） set。</p><ol><li>object.defineProperty 数据劫持</li><li>使用 getter 手动依赖，setter 通知 watch 派发更新。</li><li>watch 发布订阅</li></ol><h1 id="Vue-3-0"><a href="#Vue-3-0" class="headerlink" title="Vue 3.0"></a>Vue 3.0</h1><ol><li><p>响应式原理的改变 Vue3.x 使用Proxy。</p></li><li><p>组件选项声明方式 Vue3.x 使用 <strong>Composition API</strong> setup是Vue3.x新增的一个选项，他是组件内使用Composition API 的入口。</p></li><li><p>模板语法变化 slot 具名插槽语法，自定义指令v-model 升级</p></li><li><p>其他方面的更改 Suspense支持Fragment（多个根节点）和 Protal（在dom其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。基于 treeShaking 优化，提供了更多的内置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">treeShaking 是一种通过清除多余代码的方式来优化项目打包体积的技术，专业术语叫 Dead code elimination；是基于  ES6 模板语法（import 与 exports），主要是借助 ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个Vue实例在被创建都要经过一系列的初始化过程 --- 例如：需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等</span><br></pre></td></tr></table></figure><p><strong>PS:</strong></p><ol><li><p><strong>beforeCreate</strong>：<strong>实例刚在内存中被创建出来</strong></p></li><li><p><strong>created</strong> 钩子可以用来在一个 <strong>实例被创建之后执行代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a is: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; &quot;a is: 1&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h1><p>组件的data写成一个函数，数据以向函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全部都会变的结果。</p><h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><p>1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。</p><p>2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。</p><p>3、$attrs 和 $listeners A -&gt; B -&gt; C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。</p><p>4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）</p><p>5、$refs 获取组件实例。</p><p>6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。</p><p>7、vuex 状态管理。</p><h2 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h2><h3 id="Vue的父子组件生命周期钩子函数执行顺序"><a href="#Vue的父子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue的父子组件生命周期钩子函数执行顺序"></a>Vue的父子组件生命周期钩子函数执行顺序</h3><ol><li><strong>加载渲染过程</strong><ul><li>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</li></ul></li><li><strong>子组件更新过程</strong><ul><li>父beforeUpdate -&gt; <strong>子</strong>beforeUpdate -&gt; <strong>子</strong>updated -&gt; 父updated</li></ul></li><li><strong>父组件更新过程</strong><ul><li>父beforeUpdate -&gt; 父updated</li></ul></li><li><strong>销毁过程</strong><ul><li>父beforeDestroy -&gt; <strong>子</strong>beforeDestroy -&gt; <strong>子</strong>destroyed -&gt; 父destroyed</li></ul></li></ol><h3 id="parent-children"><a href="#parent-children" class="headerlink" title="parent + children"></a>parent + children</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指定已创建的实例之父实例，在两者之间简历父子关系。</span><br><span class="line">子实例可以用 this.$parent 访问父实例,</span><br><span class="line">子实例被推入到父实例的 this.$childer 数组中</span><br></pre></td></tr></table></figure><h3 id="provide-x2F-inject"><a href="#provide-x2F-inject" class="headerlink" title="provide &#x2F; inject"></a>provide &#x2F; inject</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provide：Object | () =&gt; Object</span><br><span class="line">inject：Array&lt;string&gt; | &#123; [key: string]: string | Symbol | Object &#125;</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><strong>provide</strong> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property</li><li>在该对象中可以使用  <strong>Symbols</strong> 作为key，但是只在原生支持 <strong>Symbol</strong> 和 <strong>Reflect.ownKeys</strong> 的环境下可工作</li><li><strong>provide</strong> 和 <strong>inject</strong> 绑定并不是可响应的。但是如果你传入了一个 <strong>可监听的对象</strong>，那么其对象的 property还是可响应的</li></ol><h3 id="on-emit"><a href="#on-emit" class="headerlink" title="$on + $emit"></a>$on + $emit</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$on(<span class="string">&#x27;test&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="comment">// =&gt; &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: [&#x27;title&#x27;],</span><br><span class="line">  template: &#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#blog-post-demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">posts</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;My journey with Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Blogging with Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;Why Vue is so fun&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p><a href="https://cn.vuejs.org/images/lifecycle.png">https://cn.vuejs.org/images/lifecycle.png</a></p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在实例初始化之后，进行数据监听和事件/监听器的配置之前同步调用</span><br><span class="line"></span><br><span class="line">实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</span><br></pre></td></tr></table></figure><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。</span><br><span class="line"></span><br><span class="line">实例已经在内存中创建🆗，此时 data 和 methods 已经创建🆗，此时还没有开始 编译模板</span><br></pre></td></tr></table></figure><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在挂载开始之前被调用：相关的 render 函数首次被调用。</span><br><span class="line">该钩子在服务器端渲染期间不被调用</span><br><span class="line"></span><br><span class="line">此时已经完成了模板的编译，但是还没有挂载到页面中</span><br></pre></td></tr></table></figure><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了</span><br><span class="line">注意：</span><br><span class="line"> mounted不会保证所有的子组件也都被挂载完成。若干是等整个视图都渲染完成再执行操作，可以在mounted中使用 vm.$nectTick</span><br><span class="line"> 该钩子在服务器端渲染期间不被调用</span><br><span class="line"></span><br><span class="line">此时，已经将编译好的模板，挂载到了页面指定的容器中显示</span><br></pre></td></tr></table></figure><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在数据发生改变后，Dom被更新之前被调用。这里适合在现有DOM 将要更新之前访问它，比如：移除手动添加的事件监听器。</span><br><span class="line"></span><br><span class="line">状态更新之前执行此函数，此时 data 中的状态值时最新的，但是界面上显示的数据还是 旧的，因为此时还没有重新渲染 DOM 节点</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用</span><br><span class="line">当这个钩子函数被调用时，组件DOM已经更新</span><br><span class="line"></span><br><span class="line">实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</span><br></pre></td></tr></table></figure><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被 keep-alive 缓存的组件激活时调用</span><br></pre></td></tr></table></figure><h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被 keep-alive 缓存的组件失活时调用</span><br></pre></td></tr></table></figure><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例销毁之前调用</span><br></pre></td></tr></table></figure><h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例销毁后调用。该钩子被调用后，对应的Vue实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也被销毁</span><br></pre></td></tr></table></figure><h2 id="父子组件生命周期"><a href="#父子组件生命周期" class="headerlink" title="父子组件生命周期"></a>父子组件生命周期</h2><h3 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeCreate -- 父created -- 父beforeMount -- 子beforeCreate -- 子created -- 子beforeMount -- 子mounted -- 父mounted</span><br></pre></td></tr></table></figure><h3 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate -- 子beforeUpdate -- 子updated -- 父updated</span><br></pre></td></tr></table></figure><h3 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate -- 父updated</span><br></pre></td></tr></table></figure><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeDestroy -- 子beforeDestroy -- 子destroyed -- f</span><br></pre></td></tr></table></figure><h2 id="异步请求在哪一步发起？"><a href="#异步请求在哪一步发起？" class="headerlink" title="异步请求在哪一步发起？"></a>异步请求在哪一步发起？</h2><ol><li>可以在钩子函数 <strong>created、beforeMount、mounted</strong> 中进行异步请求，因为在这三个钩子函数中，data已经创建，可以将服务器端返回的数据进行赋值</li><li>如果异步请求不需要依赖 DOM 推荐加载 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<ul><li>能更快获取到服务端数据，减少页面loading时间；</li><li>ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性。</li></ul></li></ol><hr><h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><ol><li>首次激活时，activated 都在mounted后</li><li>再次激活时，组件只走 <strong>activated</strong></li><li>组件失活时，<strong>均不走  beforeDestroy  和  destroyed</strong></li></ol><h3 id="使用场景和原理"><a href="#使用场景和原理" class="headerlink" title="使用场景和原理"></a>使用场景和原理</h3><p><strong>keep-alive</strong> 是Vue内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><ul><li>常用的两个属性 include&#x2F;exclude，允许组件有条件的进行缓存</li><li>两个生命周期 activated&#x2F;deactivated，用来得知当前组件是否处理活跃状态</li><li>keep-alive 运用了 <strong>LPU</strong> 算法，选择最近最久未使用的组件予以淘汰</li></ul><p><strong>扩展补充：LPU算法是什么？</strong></p><p><a href="https://imgtu.com/i/o28EjI"><img src="https://s4.ax1x.com/2021/12/08/o28EjI.png" alt="o28EjI.png" style="zoom:80%;" /></a></p><h1 id="Vue内置指令"><a href="#Vue内置指令" class="headerlink" title="Vue内置指令"></a>Vue内置指令</h1><ol><li>v-once - 定义它的元素或组件只渲染一次，包括元素或组件的所有节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。</li><li>v-cloak - 这个指令保持在元素上直到关联实例结束编译 – 解决初始化慢到页面闪动的最佳实践。</li><li>v-bind - 绑定属性，动态更新HTML元素上的属性。例如 v-bind:class。</li><li>v-on - 用于监听DOM事件。例如 v-on:click v-on:keyup</li><li>v-html - 赋值就是变量的innerHTML – 注意防止xss攻击</li><li>v-text - 更新元素的textContent</li><li>v-model - 1、在普通标签。变成value和input的语法糖，并且会处理拼音输入法的问题。2、再组件上。也是处理value和input语法糖。</li><li>v-if &#x2F; v-else &#x2F; v-else-if。可以配合template使用；在render函数里面就是三元表达式。</li><li>v-show - 使用指令来实现 – 最终会通过display来进行显示隐藏</li><li>v-for - 循环指令编译出来的结果是 -L 代表渲染列表。优先级比v-if高最好不要一起使用，尽量使用计算属性去解决。注意增加唯一key值，不要使用index作为key。</li><li>v-pre - 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度</li></ol><h1 id="Vue单向数据流"><a href="#Vue单向数据流" class="headerlink" title="Vue单向数据流"></a>Vue单向数据流</h1><p>数据总是从父组件传递给子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致应用的数据流向难以理解。</p><p><strong>注意：</strong>在子组件直接使用 v-model 绑定父组件传过来的 props 这样是不规范的写法，开发环境会报警告。如果是在要更改父组件的props 值可以在data中定义一个变量，并用props的值初始化它，之后用 $emit 来通知父组件去修改</p><h1 id="Vue实例化过程"><a href="#Vue实例化过程" class="headerlink" title="Vue实例化过程"></a>Vue实例化过程</h1><p><a href="https://imgtu.com/i/qnZOJA"><img src="https://s1.ax1x.com/2022/03/21/qnZOJA.md.png" alt="qnZOJA.md.png"></a></p><h1 id="Vue自定义指令"><a href="#Vue自定义指令" class="headerlink" title="Vue自定义指令"></a>Vue自定义指令</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定的指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册局部指令，组件中也接受一个directives</span></span><br><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h1><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.stop</span><br><span class="line">.prevent</span><br><span class="line">.capture</span><br><span class="line">.self 即事件不是从内部元素触发的</span><br><span class="line">.once</span><br><span class="line">.passive 不阻止事件的默认行为</span><br></pre></td></tr></table></figure><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure><h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br><span class="line">.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件</span><br><span class="line"></span><br><span class="line">// 鼠标按钮修饰符</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">.middle</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/07/05/JavaScript/"/>
      <url>/2022/07/05/JavaScript/</url>
      
        <content type="html"><![CDATA[<p>基础知识点随手记</p><span id="more"></span><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>是动态分布内存，大小不定也不会自动释放</strong> <strong>,栈内存</strong>中存放地址指向 <strong>堆内存中的对象</strong>.是按引用访问的。栈内存中存放的只是该对象的访问地址， 在堆内存中为这个值分配空间</p><h3 id="类型-引用数据类型"><a href="#类型-引用数据类型" class="headerlink" title="类型(引用数据类型)"></a>类型(引用数据类型)</h3><p><code>function</code> <code>Object</code> <code>Array</code></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>在内存中占据空间小、大小固定</strong>，他们的值保存在 <strong>栈空间</strong>， 是按 <strong>值</strong> 来访问</p><h3 id="类型（基本数据类型）"><a href="#类型（基本数据类型）" class="headerlink" title="类型（基本数据类型）"></a>类型（基本数据类型）</h3><p><code>Undefined | Null | Boolean | Number | String | Symbol</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object 是 JavaScript 中所有对象的父对象</span><br><span class="line">数据封装类对象：object、Array、Boolean、Number 和 String</span><br><span class="line">其他对象：Function、Arguments、Math、Date、RegExp、Er</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>为了使程序运行时占用的内存最小，通常要实现垃圾回收机制。<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈存里，随着方法的执行结束，这个方法的栈存也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本开销较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型存储在栈中，引用数据类型(对象)存储在堆中，指针放在栈中。</span><br><span class="line">　　两种类型的区别是：存储位置不同;原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储;引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能</span><br><span class="line">　　引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈(stack)：由编译器自动分配释放，存放函数的参数值，局部变量等;</span><br><span class="line"></span><br><span class="line">堆(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a的值是什么</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>,a,<span class="string">&#x27;b&#x27;</span>,b)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="keyword">var</span> m = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> n = m;</span><br><span class="line">n.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m.a 的值是什么?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m&#x27;</span>,m,<span class="string">&#x27;n&#x27;</span>,n)</span><br></pre></td></tr></table></figure><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p><strong>如何区分</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单点来说,就是假设B复制了A,当修改A时,看B是否会发生变化,如果B也跟着变了,说明这是浅拷贝,如果没变那就是深拷贝</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// demo2</span><br><span class="line">var m = &#123;a:1,b:2&#125;;</span><br><span class="line">var n = m;</span><br><span class="line">n.a = 3;</span><br><span class="line"></span><br><span class="line">// m.a 的值是什么?</span><br><span class="line">console.log(&#x27;m&#x27;,m,&#x27;n&#x27;,n)</span><br><span class="line">// 此时m.a 的值是发生变化为 3;因为 m 和 n 指向的是同一个地址,当n.a的值发生变化时,m.a的值也会发生变化</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>实现方法</strong></p><ol><li><p>采用 <strong>递归</strong> 去拷贝所有层级属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">                <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">                    objClone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=<span class="title function_">deepClone</span>(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b);</span><br></pre></td></tr></table></figure></li><li><p>通过 <strong>JSON</strong> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _obj = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line">    objClone = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(_obj)</span><br><span class="line"><span class="keyword">return</span> objClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点:无法实现对 对象中方法的深拷贝,会显示 undefined</strong></p></li><li><p>jQuery  <strong>extend</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newArray = $.<span class="title function_">extend</span>(<span class="literal">true</span>,[],array) <span class="comment">// true为深拷贝, false为浅拷贝</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://lodash.com/docs#find"><strong>lodash</strong> 函数库实现</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = _.cloneDeep(test)</span><br></pre></td></tr></table></figure></li></ol><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><strong>实现方法</strong></p><ol><li><p>for in 只循环第一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] :&#123;&#125; <span class="comment">// 判断是否为数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        obj2[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:&#123;</span><br><span class="line">        <span class="attr">d</span>:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="title function_">simpCopy</span>(test)</span><br><span class="line">test2.<span class="property">a</span> = <span class="number">4</span></span><br><span class="line">test2.<span class="property">c</span>.<span class="property">d</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>,test,<span class="string">&#x27;test2&#x27;</span>,test2) <span class="comment">// test.a === 4; test.c.d ===5</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assgin方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">vra obj2 = <span class="title class_">Object</span>.<span class="title function_">assgin</span>(obj)</span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj&#x27;</span>,obj.<span class="property">a</span>) <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p><h2 id="创建Ajax的过程"><a href="#创建Ajax的过程" class="headerlink" title="创建Ajax的过程"></a>创建Ajax的过程</h2><ol><li><p>创建XMLHttpRequest对象（异步调用对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br></pre></td></tr></table></figure></li><li><p>创建新的Http请求（方法、URL、是否异步）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&#x27;get&#x27;,&#x27;example.php&#x27;,false)</span><br></pre></td></tr></table></figure></li><li><p>设置响应HTTP请求状态变化的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onreadystatechange事件中readyState属性等于4.响应的HTTP状态为200（ok）或者304</span><br></pre></td></tr></table></figure></li><li><p>发送http请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(data)</span><br></pre></td></tr></table></figure></li><li><p>获取异步调用返回的数据</p></li></ol><p><strong>注意：</strong></p><ol><li>页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。</li><li>同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax</li><li>尽量减少ajax请求次数</li><li>ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理</li></ol><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</span><br><span class="line">　　注意：JS没有块级作用域，若要形成块级作用域，可通过(function()&#123;｝)();立即执行的形式实现</span><br></pre></td></tr></table></figure><p><strong>作用域就是代码的执行环境</strong>，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是 <strong>栈内存</strong>。概况来说  <strong>作用域就是代码执行开辟栈内存</strong></p><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行黄静都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p><p>全局执行环境是最外围的执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示的执行环境的对象也不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的</span><br><span class="line">在 node 环境中，全局执行环境是 global 对象</span><br></pre></td></tr></table></figure><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>当代码在一个环境执行时，会创建变量对象的一个作用域链（作用域形成的链条）</p><ol><li>作用域链的前端，始终都是当前执行的代码所在环境的变量对象</li><li>作用域链的下一个对象来自于外部环境，而下一个变量对象来自于下一个外部环境，一直到全局执行黄静</li><li>全局执行环境的变量对象始终都是作用域链上的最后一个对象</li><li>挡在内部函数中，需要方位一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找，知道全局作用域。如果在某个变量对象中找到则使用该变量对象中的变量值。由于变量的查找是沿着作用域链来实现的，所以也称作用域链为 <strong>变量查找的机制</strong></li></ol><h1 id="this的理解"><a href="#this的理解" class="headerlink" title="this的理解"></a>this的理解</h1><ol><li>this总是指向函数的直接调用者（而非间接调用者）</li><li>如果有<strong>new</strong>关键字，this指向 <strong>new</strong> 出来的那个对象</li><li>this 表示当前对象的一个引用。在js中 this 会随着执行环境的改变而改变<ol><li>在方法中，this 表示该方法所属的对象。</li><li>如果单独使用，this 表示全局对象。</li><li>在函数中，this 表示全局对象。</li><li>在函数中，在严格模式下，this 是未定义的(undefined)。</li><li>在事件中，this 表示接收事件的元素。</li><li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li></ol></li></ol><h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如此层层递进，就构成了实例与原型的链条。这就是所谓的<strong>原型链</strong>的基本概念。</p><h1 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h1><p><strong>相同点：</strong></p><ol><li>三者都是用来改变函数的this对象的指向的</li><li>三者第一个参数都是this要指向的对象，也就是想指定的上下文</li><li>三者都可以利用后续参数传参</li><li>三者的参数不限定 string类型，允许是各种类型，包括函数、object等</li></ol><p><strong>区别：</strong></p><ol><li><p>bind 是返回对应函数，便于稍后调用；apply、call则是立即调用。bind 返回的是一个新的函数，必须调用才会执行</p></li><li><p>回调执行使用 bind 方法，立即执行使用 apply&#x2F;call</p></li><li><p>传参不同</p><ol><li>call 的参数是直接放进去，第二个及第n个参数全部都用<strong>逗号分隔</strong></li><li>apply的参数都必须放在一个<strong>数组</strong>里面</li><li>bind 参数和call 一样，但是返回的是函数</li></ol></li></ol><h1 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。所有属性和方法都是公用的，因此子类可直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。</p><p><strong>继承的方式</strong></p><p>JavaScript中的继承机制并不是明确规定的，而是通过模仿实现的。这意味着所有的继承细节并非完全由解释程序处理。作为开发者，有权决定最适用的继承方式</p><h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><p><strong>原理：</strong></p><p>​构造函数使用this关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。应为构造函数只是一个函数，所以可使 Class A 构造函数称为 Class B的方法，然后调用它。class B 就会收到ClassA 的构造函数中定义的属性和方法</p><p><strong>实现：</strong></p><p>​关键字 <strong>this</strong> 引用的是构造函数当前创建的对象。不过在这个方法中，this 指向的所属的对象。这个原理是把classA 作为常规函数来建立继承机制，而不是作为构造函数。如下使用构造函数 classB可以实现继承机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classA</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = classA;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为 classA 赋予了方法 newMethod （函数名只是指向它的指针）。然后调用该方法，传递给它的是 classB 构造函数的参数 sColor。 最后一行代码删除了对 classA 的引用，这样以后就不能再调用它</p><p><strong>注意：</strong></p><p>​所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classA</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ClassB</span>(<span class="params">sColor, sName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = <span class="title class_">ClassA</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="title class_">ClassA</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="title class_">ClassB</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.<span class="title function_">sayName</span>();<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure><h3 id="对象冒充多重继承"><a href="#对象冒充多重继承" class="headerlink" title="对象冒充多重继承"></a><strong>对象冒充多重继承</strong></h3><p>例如，如果存在两个类 ClassX 和 ClassY，ClassZ 想继承这两个类，可以使用下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClassZ</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = <span class="title class_">ClassX</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = <span class="title class_">ClassY</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性和方法，ClassY 具有高优先级。因为它从后面的类继承。除了这点小问题之外，用对象冒充继承机制轻而易举</p><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>call()方法与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(sPrefix + <span class="variable language_">this</span>.<span class="property">color</span> + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.<span class="title function_">call</span>(obj, <span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>);</span><br><span class="line"><span class="comment">// The color is blue, a very nice color indeed.</span></span><br></pre></td></tr></table></figure><p>要与继承机制的对象冒充方法一起使用该方法，只需要将前三行的赋值、调用和删除代码替换即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor,sName</span>)&#123;</span><br><span class="line">    classA.<span class="title function_">call</span>(<span class="variable language_">this</span>,sColor);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">classA</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h2><p>apply（）方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(sPrefix + <span class="variable language_">this</span>.<span class="property">color</span> + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.<span class="title function_">apply</span>(obj, <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>));</span><br></pre></td></tr></table></figure><p>该方法也用于替换前三行的赋值、调用和删除新方法的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor,sName</span>)&#123;</span><br><span class="line">    classA.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="keyword">new</span> <span class="title class_">Array</span>(sColor));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，第一个参数仍是 this，第二个参数只是只有一个值 color 的数组，可以把 classB 的整个 argumens 对象作为第二个参数传递给 apply（）方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor,sName</span>)&#123;</span><br><span class="line">    classA.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClassA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ClassB</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">objA.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">objB.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">objB.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">objA.<span class="title function_">sayColor</span>();</span><br><span class="line">objB.<span class="title function_">sayColor</span>();</span><br><span class="line">objB.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure><h2 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClassA</span>(<span class="params">sColor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayColor</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ClassB</span>(<span class="params">sColor, sName</span>) &#123;</span><br><span class="line">    <span class="title class_">ClassA</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, sColor);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="title class_">ClassA</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="title class_">ClassB</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.<span class="title function_">sayName</span>();<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure><h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>node js 是 commonJS 规范的主要实践者</p><p>提供支持：module、exports、require、global</p><p>实际使用时，使用 module.exports 定义当前模块对外输出的接口（不推荐直接使用 exports），用require 加载模块</p><p><strong>注意：</strong></p><p>​commonJS 用<strong>同步的方式加载模块</strong>。<strong>在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</strong></p><p>Webpack <strong>不支持</strong>使用 commonjs 模块来完成 tree-shaking。</p><h2 id="AMD-和-require-js"><a href="#AMD-和-require-js" class="headerlink" title="AMD 和 require.js"></a>AMD 和 require.js</h2><p>AMD 规范采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。JavaScript 库 require.js 实现了 AMD 规范的模块化：用 <code>require.config()</code> 指定引用路径等，用 <code>define()</code> 定义模块，用 <code>require()</code> 加载模块。</p><h2 id="CMD-和-sea-js"><a href="#CMD-和-sea-js" class="headerlink" title="CMD 和 sea.js"></a>CMD 和 sea.js</h2><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：<strong>AMD 推崇依赖前置、提前执行,在定义模块的时候就要声明其依赖的模块</strong>，<strong>CMD推崇依赖就近、延迟执行，只有在用到某个模块的时候再去require</strong>，此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) &#123;      </span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块    </span></span><br><span class="line">    a.<span class="title function_">doSomething</span>(); </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;        </span><br><span class="line">    <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了        </span></span><br><span class="line">    b.<span class="title function_">doSomething</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">/** CMD写法 **/</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;    </span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); </span><br><span class="line">    <span class="comment">//在需要时申明    </span></span><br><span class="line">    a.<span class="title function_">doSomething</span>();    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;        </span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);        </span><br><span class="line">        b.<span class="title function_">doSomething</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 </span></span><br><span class="line">math.<span class="title function_">jsdefine</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;    </span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);    </span><br><span class="line">    <span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;        </span><br><span class="line">        <span class="keyword">return</span> a+b;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">add</span> = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.<span class="title function_">use</span>([<span class="string">&#x27;math.js&#x27;</span>], <span class="keyword">function</span>(<span class="params">math</span>)&#123;    </span><br><span class="line">    <span class="keyword">var</span> sum = math.<span class="title function_">add</span>(<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ES5-Module"><a href="#ES5-Module" class="headerlink" title="ES5 Module"></a>ES5 Module</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default </span><br><span class="line">import xx from xx</span><br></pre></td></tr></table></figure><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><h3 id="3-其他总结"><a href="#3-其他总结" class="headerlink" title="3. 其他总结"></a>3. 其他总结</h3><ol><li>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li><li>ES6 的 module 是同步还是异步的？异步的。CommonJS 不支持异步</li><li>ESModule 既然是编译时加载，那可以做到运行时加载吗？（webpack 有动态import 方式）</li><li>ES6 module 语法是静态的，CommonJS 语法是动态的</li><li>ES6 module 作为新的规范，可以替代之前的 AMD、CMD、CommonJS 作为浏览器和服务端的通用模块方案</li></ol><h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p><strong>特点</strong></p><ol><li>存在服务器端</li><li>默认session的存储在服务器的 <strong>内存</strong> 中，每当一个新客户端发来请求，服务器都会开辟一个新的空间</li><li>cookie一般会配合session使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git分支命令</title>
      <link href="/2022/07/04/git%E5%88%86%E6%94%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/04/git%E5%88%86%E6%94%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add xxx 或 .  --&gt; 将工作区的文件添加到暂存区(暂时保存,即将交给git进行版本管理)</span><br><span class="line">git commit -m &#x27;&#x27; / git commit -m [xxx] --&gt; &#x27;提交信息&#x27; 将暂存区的文件添加到版本</span><br><span class="line">git status 红色表示在工作区/绿色表示在暂存区</span><br><span class="line">git reset --soft HEAD^ --&gt; 撤回commit(保存修改)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff --&gt; 比较暂存区与工作区</span><br><span class="line">git diff --cached --&gt; 比较版本区与暂存区</span><br><span class="line">git diff master --&gt; 比较版本区与工作区</span><br><span class="line"></span><br><span class="line">git diff branch1 branch2 --&gt; 显示出两个分支之间所有有差异的文件的详细差异</span><br><span class="line">git diff branch1 branch2 --start --&gt; 显示两个分支之间所有有差异的文件列表</span><br><span class="line">git diff branch1 branch2 xxx --&gt; 显示指定文件的详细差异</span><br></pre></td></tr></table></figure><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git log --&gt; 显示从最近到最u按的所有提交日志,如果出现 &#x27;:&#x27; 表示为输出完成,出现end后最后完成</span><br><span class="line">git reflog --&gt; 显示每次提交(commit)的 commit id</span><br><span class="line">git reset --hard HEAD^ --&gt; 版本回退(回退一次提交),^^表示回退两次 - 最多回退两次</span><br><span class="line">git reset --hard 版本号 --&gt; 回退到指定版本号的commit id 版本</span><br><span class="line">git reset --soft 版本号 --&gt; 回退到指定版本号的commit id 并暂存修改后的文件</span><br><span class="line"></span><br><span class="line">git reset HEAD --&gt; 用版本库中的文件去替换暂存区的全部文件</span><br><span class="line">git checkout --x.txt --&gt; 用暂存区指定的文件去替换工作区的指定文件(危险操作)</span><br><span class="line">git checkout HEAD x.txt --&gt; 用版本库中的文件替换暂存区和工作区的文件(危险操作)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm x.txt --&gt; 删除文件</span><br><span class="line">git rm -r xxx --&gt; 删除文件夹</span><br><span class="line">git rm --cached x.txt --&gt;从暂存区删除文件</span><br></pre></td></tr></table></figure><h2 id="分支相关指令"><a href="#分支相关指令" class="headerlink" title="分支相关指令"></a>分支相关指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git fetch origin xxx:xxx  --拉取 &#x27;分支&#x27;（目标分支）并在本地创建 xxx 分支</span><br><span class="line"></span><br><span class="line">git checkout xxx --&gt; 切换xxx分支</span><br><span class="line">git checkout -b dev --&gt; 创建dev分支,并切换到dev分支</span><br><span class="line">git checkout -b xxx origin/xxx --&gt;拉取远程分支并在本地创建该分支</span><br><span class="line"></span><br><span class="line">git branch --&gt; 查看当前分支</span><br><span class="line">git branch -r --&gt; 查看远程所有分支</span><br><span class="line">git branch xxx --&gt; 创建xxx分支</span><br><span class="line">git branch -D branchName --&gt; 删除本地指定分支</span><br><span class="line"></span><br><span class="line">git push origin -d branchName --&gt; 删除远程指定分支</span><br><span class="line">git merge xxx --&gt; 合并xxx分支到当前分支</span><br><span class="line"></span><br><span class="line">git commit --amend --&gt; 修改最新的一次提交commit</span><br><span class="line">i --&gt; 进入修改模式</span><br><span class="line">Esc --&gt; 退出编辑模式</span><br><span class="line">:wq --&gt;  保存并退出</span><br></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog --&gt; 查看本地记录</span><br><span class="line">git rebase -i xxx  --&gt;合并commit</span><br><span class="line">i --&gt; 插入</span><br><span class="line">:wq --&gt; 保存退出</span><br></pre></td></tr></table></figure><h3 id="gitk-–all"><a href="#gitk-–all" class="headerlink" title="gitk –all"></a>gitk –all</h3><ul><li>查看 git 分支提交线</li></ul><h1 id="Git密码操作"><a href="#Git密码操作" class="headerlink" title="Git密码操作"></a>Git密码操作</h1><p>记住密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper wincred</span><br></pre></td></tr></table></figure><p>清空本地密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git credential-manager uninstall</span><br></pre></td></tr></table></figure><p>保存新密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制面板 -&gt; 用户账户 -&gt; 凭据管理器 -&gt; 普通凭据 -&gt; git:https://github.com -&gt; 编辑</span><br></pre></td></tr></table></figure><h1 id="Git-项目操作流程"><a href="#Git-项目操作流程" class="headerlink" title="Git 项目操作流程"></a>Git 项目操作流程</h1><p><img src="https://s1.ax1x.com/2020/06/17/NZVWP1.png"></p><p>远程有修改,拉取本地操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master  --&gt; 拉取到本地  -第1种</span><br><span class="line">git fetch origin master:tmp --&gt; 新建一个tmp分支,将远程仓库的master分支代码版本复制到tmp分支上,不会自动合并  -第2种</span><br></pre></td></tr></table></figure><p>克隆到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &#x27;仓库地址&#x27;  --&gt;目前只有一个分支</span><br><span class="line">git checkout -b &#x27;本地分支&#x27; origin/&#x27;远程分支&#x27; --&gt;根据远程分支来创建本地另一个分支</span><br><span class="line">git pull --&gt;拉取远程仓库的全部东西</span><br><span class="line">Octotree --&gt;GitHub管理器(chrome插件)</span><br></pre></td></tr></table></figure><h2 id="协作开发"><a href="#协作开发" class="headerlink" title="协作开发"></a>协作开发</h2><ol><li>GitHub官网 –&gt; New organization(创建团队&#x2F;组织)</li><li>选择free 或者其他</li><li>输入组织名称&#x2F;联系邮箱</li><li>进行权限配置</li><li>创建新的仓库 -&gt;私有化</li><li>添加成员,添加成员的账户名或者邮箱</li><li>对成员进行权限的配置(读&#x2F;写&#x2F;管理员)</li><li>发送邀请,成员同意</li></ol><h2 id="合并分支-差异对比"><a href="#合并分支-差异对比" class="headerlink" title="合并分支(差异对比)"></a>合并分支(差异对比)</h2><ol><li><p>远程分支有更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --&gt; 将远程分支拉取到本地,并在本地新建一个与远程分支名字一样的本地分支</span><br><span class="line">git fetch origin xxx远程分支名 --&gt;拉取xxx远程分支变为本地分支</span><br></pre></td></tr></table></figure></li><li><p>从远程分支拉取到本地分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch 本地分支名  --&gt; 新建本地分支</span><br><span class="line">git pull origin xxx远程分支名  --&gt; 拉取远程分支的代码到新建的本地分支</span><br></pre></td></tr></table></figure></li><li><p>建立本地分支与远程分支的跟踪联系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1- git branch -vv --&gt; 可以查看本地分支对应的远程分支</span><br><span class="line"></span><br><span class="line">git checkout -b dev origin/dev --&gt; 在远程分支的基础上建立dev分支,并且让dev分支追踪origin/branch-name</span><br><span class="line"></span><br><span class="line">2- git分支追踪远程分支</span><br><span class="line"></span><br><span class="line">git branch --set-upstream test origin/master --&gt;建立本地仓test并建立追踪关系,如果建立了本地仓也建立了追踪会修改追踪关系(建议使用)</span><br><span class="line">git branck --track test origin/develop</span><br><span class="line"></span><br><span class="line">3- 修改追踪关系,切换到test</span><br><span class="line">git checkout test</span><br><span class="line">git branch --sett-upstream-to origin/master</span><br></pre></td></tr></table></figure></li><li><p>git合并远程拉取的分支与本地修改的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 先使用 git stash 暂存本地修改的部分</span><br><span class="line">2- 再使用 git pull 拉取到远程分支</span><br><span class="line">3- 使用 git stash pop 弹出本地修改部分,此时git会自动合并</span><br></pre></td></tr></table></figure></li></ol><h1 id="GitFork"><a href="#GitFork" class="headerlink" title="GitFork"></a>GitFork</h1><ol><li><pre><code>git clone 地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   git remote add upstream 地址(将b项目作为最新代码的参考标准 -- upstream 是上有仓库的别名,别名可随意命名)</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>在本地更改代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   git add . </span><br><span class="line">   git stash 暂存本地代码</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>拉取远程代码git pull / git fetch upstream</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 协同开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/02/hello-world/"/>
      <url>/2022/07/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
