<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS</title>
      <link href="/2022/09/20/CSS/"/>
      <url>/2022/09/20/CSS/</url>
      
        <content type="html"><![CDATA[<p>CSS 基础</p><span id="more"></span><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h2><p>盒子实际内容（content）的 width&#x2F;height &#x3D; 设置的 width&#x2F;height</p><p>盒子总宽度&#x2F;高度 &#x3D; width&#x2F;height + padding + border + margin</p><h2 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h2><p>盒子的width&#x2F;height  + padding + border &#x3D; 我们设置的width&#x2F;height</p><h2 id="属性选择（box-sizing）"><a href="#属性选择（box-sizing）" class="headerlink" title="属性选择（box-sizing）"></a>属性选择（box-sizing）</h2><ol><li><p><strong>content-box</strong>  </p><ol><li><p>宽度和高度分别引用到元素的内容框</p></li><li><p>在宽度和高度之外绘制元素的内边距和</p></li></ol></li><li><p><strong>border-box</strong></p><ol><li><p>为元素设定的宽度和高度决定了元素的边框盒</p></li><li><p>为元素指定的任何内边距和边框都将在已设定的狂赌和高度内进行绘制</p></li><li><p>通过从已设定的宽度和 分别减去边框和内边距才能得到内容的宽度和高度</p></li></ol></li><li><p><strong>inherit</strong></p><ol><li>规定应从父元素继承 <strong>box-sizing</strong> 属性的值</li></ol></li><li><p><strong>content-box</strong></p><ol><li><p>指定盒子模型为W3C（标准盒模型）</p></li><li><p>border-box 为IE盒模型（怪异盒模型）</p></li></ol></li></ol><h1 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ol><li>标签选择器   </li><li>ID   </li><li>类</li><li>属性</li><li>派生（后代、子元素、兄弟）</li><li>通配符选择器 *****</li><li>!important  </li><li>内联样式表</li></ol><h2 id="权重计算规则"><a href="#权重计算规则" class="headerlink" title="权重计算规则"></a>权重计算规则</h2><ol><li>代表内联样式，如: style&#x3D;””，权值为1000。</li><li>代表ID选择器，如：#content，权值为0100。</li><li>代表类，伪类和属性选择器，如.content，权值为0010。</li><li>代表类型选择器和伪元素选择器，如div p，权值为0001。</li><li>通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。</li><li>继承的样式没有权值。</li></ol><h2 id="rem-em-px"><a href="#rem-em-px" class="headerlink" title="rem em px"></a>rem em px</h2><ol><li>em 相对于父元素字体大小</li><li>rem 相对于根元素</li><li>px 是固定的像素，一旦设置了就无法因为适应页面大小而改变</li></ol><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><ol><li>代码适配</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">win, lib</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> doc = win.<span class="property">document</span>; <span class="comment">//当前文档对象</span></span><br><span class="line">  <span class="keyword">var</span> docEl = doc.<span class="property">documentElement</span>; <span class="comment">//文档对象根元素的只读属性</span></span><br><span class="line">  <span class="keyword">var</span> metaEl = doc.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> flexibleEl = doc.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;flexible&quot;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> scale = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> tid;</span><br><span class="line">  <span class="keyword">var</span> flexible = lib.<span class="property">flexible</span> || (lib.<span class="property">flexible</span> = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEl) &#123; </span><br><span class="line">  <span class="comment">//当meta中viewport的标签设置了scale时，将根据scale手动设置dpr</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;将根据已有的meta标签来设置缩放比例&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> match = metaEl.<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>).<span class="title function_">match</span>(<span class="regexp">/initial\-scale=([\d\.]+)/</span>);</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">          scale = <span class="built_in">parseFloat</span>(match[<span class="number">1</span>]);</span><br><span class="line">          dpr = <span class="built_in">parseInt</span>(<span class="number">1</span> / scale);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flexibleEl) &#123;   </span><br><span class="line">  <span class="comment">//当meta中flexible的标签存在时，据此设置dpr</span></span><br><span class="line">      <span class="keyword">var</span> content = flexibleEl.<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (content) &#123;</span><br><span class="line">          <span class="keyword">var</span> initialDpr = content.<span class="title function_">match</span>(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>);</span><br><span class="line">          <span class="keyword">var</span> maximumDpr = content.<span class="title function_">match</span>(<span class="regexp">/maximum\-dpr=([\d\.]+)/</span>);</span><br><span class="line">          <span class="keyword">if</span> (initialDpr) &#123;</span><br><span class="line">              dpr = <span class="built_in">parseFloat</span>(initialDpr[<span class="number">1</span>]);</span><br><span class="line">              scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).<span class="title function_">toFixed</span>(<span class="number">2</span>));    </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (maximumDpr) &#123;</span><br><span class="line">              dpr = <span class="built_in">parseFloat</span>(maximumDpr[<span class="number">1</span>]);</span><br><span class="line">              scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).<span class="title function_">toFixed</span>(<span class="number">2</span>));    </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dpr &amp;&amp; !scale) &#123; </span><br><span class="line">  <span class="comment">//根据js获取到的devicePixelRatio设置dpr及scale，scale是dpr的倒数</span></span><br><span class="line">      <span class="keyword">var</span> isAndroid = win.<span class="property">navigator</span>.<span class="property">appVersion</span>.<span class="title function_">match</span>(<span class="regexp">/android/gi</span>);</span><br><span class="line">      <span class="keyword">var</span> isIPhone = win.<span class="property">navigator</span>.<span class="property">appVersion</span>.<span class="title function_">match</span>(<span class="regexp">/iphone/gi</span>);</span><br><span class="line">      <span class="keyword">var</span> devicePixelRatio = win.<span class="property">devicePixelRatio</span>;</span><br><span class="line">      <span class="keyword">if</span> (isIPhone) &#123;</span><br><span class="line">          <span class="comment">// iOS下，对于2和3的屏，分别用2和3倍方案</span></span><br><span class="line">          <span class="keyword">if</span> (devicePixelRatio &gt;= <span class="number">3</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">3</span>)) &#123;                </span><br><span class="line">              dpr = <span class="number">3</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (devicePixelRatio &gt;= <span class="number">2</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">2</span>))&#123;</span><br><span class="line">              dpr = <span class="number">2</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              dpr = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 其他设备下，仍旧使用1倍的方案</span></span><br><span class="line">          dpr = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      scale = <span class="number">1</span> / dpr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  docEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-dpr&#x27;</span>, dpr);</span><br><span class="line">  <span class="comment">//文本字号不建议使用rem，flexible适配方案中，文本使用px作为单位，使用[data-dpr]属性来区分不同dpr下的文本字号</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!metaEl) &#123;</span><br><span class="line">  <span class="comment">//添加meta标签，设置name为viewport，content根据scale设置缩放比(默认、最大、最小缩放比)</span></span><br><span class="line">      metaEl = doc.<span class="title function_">createElement</span>(<span class="string">&#x27;meta&#x27;</span>);</span><br><span class="line">      metaEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>);</span><br><span class="line">      metaEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;initial-scale=&#x27;</span> + scale + <span class="string">&#x27;, maximum-scale=&#x27;</span> + scale + <span class="string">&#x27;, minimum-scale=&#x27;</span> + scale + <span class="string">&#x27;, user-scalable=no&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (docEl.<span class="property">firstElementChild</span>) &#123;</span><br><span class="line">          docEl.<span class="property">firstElementChild</span>.<span class="title function_">appendChild</span>(metaEl);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> wrap = doc.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">          wrap.<span class="title function_">appendChild</span>(metaEl);</span><br><span class="line">          doc.<span class="title function_">write</span>(wrap.<span class="property">innerHTML</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">refreshRem</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">//更新rem值</span></span><br><span class="line">      <span class="keyword">var</span> width = docEl.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span>;</span><br><span class="line">      <span class="keyword">if</span> (width / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">          width = <span class="number">540</span> * dpr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> rem = width / <span class="number">10</span>; <span class="comment">//1rem = viewWidth / 10</span></span><br><span class="line">      docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">      flexible.<span class="property">rem</span> = win.<span class="property">rem</span> = rem;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查看rem&#x27;</span>,flexible.<span class="property">rem</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//resize与pageshow延时300ms触发refreshRem(),使用防抖函数，防止事件被高频触发可能引起性能问题</span></span><br><span class="line">  win.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">      tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  win.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">//当一条会话历史纪录被执行的时候触发事件，包括后退/前进按钮，同时会在onload页面触发后初始化页面时触发</span></span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;<span class="comment">//表示网页是否来自缓存</span></span><br><span class="line">          <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">          tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在html文档加载和解析完成后设置body元素字体大小</span></span><br><span class="line">  <span class="keyword">if</span> (doc.<span class="property">readyState</span> === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">      doc.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="number">12</span> * dpr + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">          doc.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="number">12</span> * dpr + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">      &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//浏览器有最小字体限制，css在pc上font-size是12px(移动端最小是8px), 也就是css像素是12，其DPR为1，在移动端dpr有可能为2和3，为了保证字体不变小，需要用12*dpr进行换算。</span></span><br><span class="line"> </span><br><span class="line">  <span class="title function_">refreshRem</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//实现rem与px相互转换</span></span><br><span class="line">  flexible.<span class="property">dpr</span> = win.<span class="property">dpr</span> = dpr;</span><br><span class="line">  flexible.<span class="property">refreshRem</span> = refreshRem;</span><br><span class="line">  flexible.<span class="property">rem2px</span> = <span class="keyword">function</span>(<span class="params">d</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> val = <span class="built_in">parseFloat</span>(d) * <span class="variable language_">this</span>.<span class="property">rem</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> d === <span class="string">&#x27;string&#x27;</span> &amp;&amp; d.<span class="title function_">match</span>(<span class="regexp">/rem$/</span>)) &#123;</span><br><span class="line">          val += <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  flexible.<span class="property">px2rem</span> = <span class="keyword">function</span>(<span class="params">d</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> val = <span class="built_in">parseFloat</span>(d) / <span class="variable language_">this</span>.<span class="property">rem</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> d === <span class="string">&#x27;string&#x27;</span> &amp;&amp; d.<span class="title function_">match</span>(<span class="regexp">/px$/</span>)) &#123;</span><br><span class="line">          val += <span class="string">&#x27;rem&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">window</span>[<span class="string">&#x27;lib&#x27;</span>] || (<span class="variable language_">window</span>[<span class="string">&#x27;lib&#x27;</span>] = &#123;&#125;));</span><br></pre></td></tr></table></figure><ol start="2"><li>flexible.js 适配</li></ol><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><ol><li><p>flex-direction  属性决定株洲的方向（项目的排列方向）</p><ol><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ol></li><li><p>flex-wrap</p><ol><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ol></li><li><p>align-content</p><ol><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机试题</title>
      <link href="/2022/07/14/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/07/14/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>主要是JavaScript相关： Promise、this、数组、字符串</p><span id="more"></span><h1 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">RESOLVE</span> = <span class="string">&#x27;resolve&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">REJECT</span> = <span class="string">&#x27;reject&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">        self.<span class="property">data</span> = <span class="literal">undefined</span></span><br><span class="line">        self.<span class="property">callback</span> = []</span><br><span class="line">        self.<span class="property">status</span> = <span class="variable constant_">PENDING</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">                self.<span class="property">status</span> = <span class="variable constant_">RESOLVE</span></span><br><span class="line">                self.<span class="property">data</span> = value</span><br><span class="line">                <span class="keyword">if</span> (self.<span class="property">callback</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    self.<span class="property">callback</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">ele</span> =&gt;</span> ele.<span class="title function_">onResolved</span>(value))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">                self.<span class="property">status</span> = <span class="variable constant_">REJECT</span></span><br><span class="line">                self.<span class="property">data</span> = value</span><br><span class="line">                <span class="keyword">if</span> (self.<span class="property">callback</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    self.<span class="property">callback</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">ele</span> =&gt;</span> ele.<span class="title function_">onRejected</span>(value))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolve, onReject</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">        onResolve = <span class="keyword">typeof</span> onResolve === <span class="string">&#x27;function&#x27;</span> ? onResolve : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">        onReject = <span class="keyword">typeof</span> onReject === <span class="string">&#x27;function&#x27;</span> ? onReject : <span class="function"><span class="params">reson</span> =&gt;</span> &#123; <span class="keyword">throw</span> reson &#125;</span><br><span class="line">        <span class="comment">// 返回一个Promise 函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = <span class="title function_">callback</span>(self.<span class="property">data</span>)</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">                        result.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> then = result.<span class="property">then</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                            <span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="title function_">resolve</span>(then)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  进行下一步判断</span></span><br><span class="line">            <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">RESOLVE</span>) &#123;</span><br><span class="line">                <span class="title function_">resolvePromise</span>(onResolve)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="variable constant_">REJECT</span>) &#123;</span><br><span class="line">                <span class="title function_">resolvePromise</span>(onReject)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                self.<span class="title function_">callback</span>(&#123; <span class="title function_">onResolve</span>(<span class="params">value</span>) &#123; <span class="title function_">resolvePromise</span>(onResolve) &#125;, <span class="title function_">onReject</span>(<span class="params">value</span>) &#123; <span class="title function_">resolvePromise</span>(onReject) &#125; &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;shuzu&#x27;</span>))</span><br><span class="line">        <span class="keyword">const</span> resultArray = []</span><br><span class="line">        <span class="keyword">let</span> resultCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(ele).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                    resultCount++</span><br><span class="line">                    resultArray[index] = value</span><br><span class="line">                    <span class="keyword">if</span> (resultCount === arr.<span class="property">length</span>) &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(resultArray)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">reject</span>(err))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;shuzu&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(ele).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">resolve</span>(value) &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> <span class="title function_">reject</span>(reason))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">Promise</span> = <span class="title class_">Promise</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br></pre></td></tr></table></figure><h1 id="this-相关"><a href="#this-相关" class="headerlink" title="this 相关"></a>this 相关</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.a&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTime&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTime-function&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">one</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>,<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">two</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>,<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">one</span>()</span><br><span class="line">obj.<span class="title function_">two</span>()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">b</span>()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a,b,c</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a*x + b*x + c</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test_add&#x27;</span>, <span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr-0&#x27;</span>,arr[<span class="number">0</span>],<span class="string">&#x27;aaaa&#x27;</span>,arr);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">firstName,lastName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newPerson = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> personTwo = <span class="title class_">Person</span>(<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;456&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person_new&#x27;</span>,newPerson);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person_two&#x27;</span>,personTwo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个函数对比是否等价 - false</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">bar</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">bar</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码比较&#x27;</span>, <span class="title function_">foo1</span>(), <span class="string">&#x27;foo2&#x27;</span>, <span class="title function_">foo2</span>(), <span class="string">&#x27;diff&#x27;</span>, foo1 === foo2);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">A</span>().<span class="title function_">getName</span>()</span><br><span class="line"><span class="title function_">A</span>().<span class="title function_">getAge</span>()</span><br><span class="line"><span class="title function_">B</span>()</span><br><span class="line"><span class="title function_">B</span>().<span class="title function_">getName</span>()</span><br><span class="line">B.<span class="title function_">getAge</span>()</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><ol><li><p>递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; arr.<span class="property">length</span>; index++)&#123;</span><br><span class="line"><span class="keyword">const</span> element = arr[index]</span><br><span class="line">        <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(element)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>reauce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(two) ? <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(two):two)</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br></pre></td></tr></table></figure></li><li><p>split + toString</p></li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    arr = arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item += item</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newArr </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)))&#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;test1&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: &#123;&#125;, <span class="attr">name</span>: <span class="string">&#x27;ssdf&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="function">() =&gt;</span> &#123; &#125;, <span class="attr">name</span>: <span class="string">&#x27;sf&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;6&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;test3&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">name</span>: <span class="string">&#x27;test4&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">name</span>: <span class="string">&#x27;test7&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;test2&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;sf&#x27;</span> &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 写下你的代码   </span></span><br><span class="line">    <span class="keyword">let</span> listArr = []</span><br><span class="line">    <span class="keyword">let</span> list = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">typeof</span> value.<span class="property">id</span>) === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    list.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="property">id</span> - b.<span class="property">id</span></span><br><span class="line">    &#125;)</span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        listArr.<span class="title function_">push</span>(element.<span class="property">name</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> listArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;过滤数据&#x27;</span>, <span class="title function_">filterSort</span>(source));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串加减"><a href="#字符串加减" class="headerlink" title="字符串加减"></a>字符串加减</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符串加数字&#x27;</span>, <span class="string">&#x27;5&#x27;</span> + <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符串减数字&#x27;</span>,<span class="string">&#x27;5&#x27;</span> - <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符串加布尔值&#x27;</span>,<span class="string">&#x27;1&#x27;</span> + <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符串加布尔值&#x27;</span>,<span class="string">&#x27;1&#x27;</span> + <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符串减布尔值&#x27;</span>,<span class="string">&#x27;1&#x27;</span> - <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符串减布尔值&#x27;</span>,<span class="string">&#x27;1&#x27;</span> - <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="判断回文字符串"><a href="#判断回文字符串" class="headerlink" title="判断回文字符串"></a>判断回文字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">str</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">     <span class="keyword">return</span> str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">resever</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) === str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础</title>
      <link href="/2022/07/07/React/"/>
      <url>/2022/07/07/React/</url>
      
        <content type="html"><![CDATA[<p>React 基础整理</p><span id="more"></span><h1 id="React-基础"><a href="#React-基础" class="headerlink" title="React 基础"></a>React 基础</h1><h2 id="组件传递参数-props"><a href="#组件传递参数-props" class="headerlink" title="组件传递参数 props"></a>组件传递参数 props</h2><p>  组件名称采用大驼峰 (Camelcase)</p><h2 id="State-生命周期"><a href="#State-生命周期" class="headerlink" title="State + 生命周期"></a>State + 生命周期</h2><p>  使用setState() 修改 State (不能直接修改State PS：this.state.comment &#x3D; ‘hello’)</p><p>  State 状态异步更新 PS：this.setState((state,props)&#x3D;&gt;{</p><p>​    counter:state.counter + props.increment</p><p>  })</p><p>  State 里的键值对数据可以单独拿出来进行更新 PS：this.setState({counter:xxx}) this.setState({date:xxx})</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>  事件命名采用小驼峰 (camelCase)</p><p>  使用 JSX 语法时需要传入一个函数作为事件处理函数，不是一个字符串 PS：&lt;button onClick-{}&gt; Active Lasers </button></p><p>  在React中不能通过返回 false 的方式阻止默认行为。必须使用 preventDefault。PS：e.preventDefault()；e是一个合成事件不需要担心跨浏览器的兼容性问题</p><p>  为了在事件回调中使用 <code>this</code>，这个绑定是必不可少的。 PS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.handleClick = this.handleClick.bind(this)</span><br><span class="line"></span><br><span class="line">   handleClick()&#123;</span><br><span class="line">     this.setState(state=&gt;&#123;</span><br><span class="line">         isToggleOn:!state.isToggleOn</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // class 的方法默认是不会绑定this。若是忘记绑定this，当调用这个函数的时候 this 的值为 undefined。</span><br><span class="line"></span><br><span class="line">   // class fields 正确的绑定回调函数：</span><br><span class="line"></span><br><span class="line">    handleClick = () =&gt; &#123;</span><br><span class="line">       console.log(&#x27;this is&#x27;, this)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>​    使用箭头函数(不推荐)，在该回调函数作为 props 传入子组件时，这些组件可能会进行额外的重新渲染。建议在构造器中绑定或使用 class fields 语法来避免这类性能问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>  事件处理程序传递参数</p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>​    上述两种方式是等价的，分别通过 箭头函数 和 Function.prototype.bind 来实现</p><p>​    在这两种情况下，React的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显示的进行传递，而通过 bing 的方式，事件对象以及更多的参数将会被隐士的进行传递</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ol><li>​    &amp;&amp; 与运算符</li><li>​    ? : 三目运算符</li><li>​    阻止组件渲染</li><li>​     在组件的 render 方法中返回 null 并不会影响组件的生命周期</li></ol><h2 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h2><p>  <strong>万不得已可以使用元素索引 index 作为 key</strong></p><ol><li><p>​    若列表的顺序可能会发生变化，不建议索引使用作为 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。React 默认使用索引作为列表项目的 key 值</p></li><li><p>​    key 只是在兄弟节点之间必须唯一</p></li><li><p>​    key 会传递信息给 React，但不会传递给组件。若组件中需要使用 key 属性的值，请使用其他属性名显式传递这个值</p></li><li><p>​      ps：组件不能读取 props.key 用 key 提取组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line"></span><br><span class="line">    // 正确！这里不需要指定 key：</span><br><span class="line"></span><br><span class="line">    return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line"></span><br><span class="line">    const numbers = props.numbers;</span><br><span class="line"></span><br><span class="line">    const listItems = numbers.map((number) =&gt;</span><br><span class="line"></span><br><span class="line">        // 正确！key 应该在数组的上下文中被指定</span><br><span class="line"></span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &lt;ul&gt;&#123;listItems&#125; &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"></span><br><span class="line">    document.getElementById(&#x27;root&#x27;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ol><li>在React里，HTML表单元素的工作方式和其他 DOM 元素有些不同，表单元素通常会保持一些内部的 state。</li><li>受控组件<ol><li>在React中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新</li><li>渲染表单的 React 组件还控制着用户输入过程中表单发生的操作，被 react 以这种方式控制取值的表单输入元素就叫做“受控组件”</li></ol></li></ol><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><ol><li>两个子组件的数据同步<ol><li>将子组件共同的数据提取到父组件中（props 是只读的）<ul><li>因为props是只读的，所以在React中可以通过使用“<strong>受控组件</strong>”来解决</li><li>在父组件中定义子组件中需要触发的方法，当其中一个输入框发生变化则另一个输入框也跟随变化（通过重新设置值）</li></ul></li></ol></li></ol><h2 id="组合-VS-继承-（重点）"><a href="#组合-VS-继承-（重点）" class="headerlink" title="组合 VS 继承 （重点）"></a>组合 VS 继承 （重点）</h2><p>  <a href="https://react.docschina.org/docs/composition-vs-inheritance.html">https://react.docschina.org/docs/composition-vs-inheritance.html</a></p><p>  在Facebook中没有发现需要使用继承来构建组件层次的情况（原文）</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>  主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差</p><p>  <strong>API:</strong> </p><p>​    <strong>React.createContext</strong></p><ol><li>创建一个Context对象。当React渲染一个订阅了这个Context对象的组件，这个组件会从组件树中离自身那个匹配的 Provider 中读取到当前的 context 值</li><li>只有当组件所处的树中没有匹配到Provider时，其defaultValue参数才会生效。</li><li><strong>注意：</strong><ol><li>将undefined传递给 Provide 的 value时，消费组件的 defaultValue不会生效</li><li>每一个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅context的变化</li></ol></li></ol><h2 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h2><p>   部分UI的js错误不应该导致整个应用崩溃，为了解决这个问题，React 16引入了一个新的概念 — 错误边界</p><p>   错误边界时一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。</p><p>   <strong>注意：</strong> 错误边界仅可以捕获其子组件的错误，无法捕获其自身的错误。</p><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><p>​    React中的一个常见模式时一个组件返回多个元素。Fragments允许将子列表分组，无需向 DOM 添加额外节点</p><p>​    用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//  正确：可以输出 &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">class Columns extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line"></span><br><span class="line">            &lt;React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">                &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                &lt;td&gt;World&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//错误：如果在组件中的 render() 中使用父div，则生成的 HTML 将无效</span><br><span class="line"></span><br><span class="line">class Columns extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line"></span><br><span class="line">            &lt;div&gt;</span><br><span class="line"></span><br><span class="line">                &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">                &lt;td&gt;World&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       </p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>​    高阶组件时参数为组件，返回值为新组件的函数。组件时将props转换为 UI，而高阶组件是将组件转换为另一个组件</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>​    指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>​    <strong>JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。</strong></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>​    用户定义的<strong>组件必须以大写字母开头</strong>，如果需要一个以小写字母开头的组件，则在JSX中使用它之前，必须将它赋值给一个大写字母开头的变量</p><p>​    Props 默认值是 true；当 props.messages 是空数组时，0 仍然会被渲染，如果需要渲染 false、true、null、undefined等值时，需要先将它们转换为字符串</p><h2 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h2><ol><li><p>比对不同类型的元素</p><ol><li><p>当根节点为不同类型的而元素时，React会拆卸原有的树并建立起新的树。</p></li><li><p>当拆卸一个树时，对应DOM节点也会被销毁。组件实例将执行 componentWillUnmount()方法。当建立一颗新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 componentWillMount 方法。紧接着 componentDidMount() 方法。所有跟之前的树所关联的 state 也会被销毁。</p></li></ol></li><li><p>比对同一类型的元素</p><ol><li><p>当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅对比及更新有改变的属性</p></li><li><p>通过比对这两个元素，React 知道只需要修改 DOM 元素上的 className 属性。</p></li><li><p>当更新 style 属性时，React 仅更新有所更变的属性</p><ol start="3"><li>比对同一类型的组件元素<br>1. 当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。<br>2. 下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。</li></ol></li></ol></li><li><p>对子节点进行递归</p><ol><li>在默认条件下，当递归 DOM 节点的子元素时，React 会同时便利两个子元素的李彪；当产生差异时，生成一个 mutation。</li><li>在子元素列表末尾新增元素时，更变开销比较小</li></ol></li></ol><h2 id="React-API"><a href="#React-API" class="headerlink" title="React API"></a>React API</h2><p>​    <a href="https://react.docschina.org/docs/react-component.html">https://react.docschina.org/docs/react-component.html</a></p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​      Hook 不能在 class 组件中使用，Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。\</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>​      Hook 是向下兼容的，可以在不编写class 的情况下使用 state 以及其他的 React 特性</p><h3 id="state-Hook"><a href="#state-Hook" class="headerlink" title="state Hook"></a>state Hook</h3><p>​      <strong>声明变量</strong></p><p>​      PS：const [count,setCount] &#x3D; useState(0)  count 是声明变量，setCount 是对 count 进行赋值时进行调用；</p><ol><li><p>这种 JavaScript 语法叫数组解构。它意味着我们同时创建了 count 和 setCount 两个变量，count 的值为 useState 返回的第一个值，setCount 是返回的第二个值</p></li><li><p>当我们使用 useState 定义state变量时候，它返回一个有两个值的数组。第一个值是当前的state，第二个值是更新 state 的函数。使用 [0] [1]来访问有点令人困惑，所以使用数组解构的原因</p></li></ol><h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h3><ol><li><p>可以在组件渲染后实现各种不同的副作用。副作用可能需要清除，所以需要返回一个函数 PS：return xxx（函数）、</p></li><li><p>可以通过跳过 Effect 进行性能优化。PS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    document.title = `It&#x27;s $&#123;count&#125; times`</span><br><span class="line"></span><br><span class="line">&#125;, [count]) // 仅在 count 更改时更新</span><br></pre></td></tr></table></figure><ol start="3"><li>React 会在渲染时将前一次渲染的数据和后一次渲染的数据进行对比，如果所有的元素都是相等的，React 会跳过这个 effect，这就实现了性能的优化</li><li>如果想执行只运行一次的 effect （仅在组件挂在和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 – 它依然遵循依赖数组的工作方式</li></ol></li></ol><h3 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h3><ol><li><p>react 通过 Hook 调用顺序来知道 state 对应的哪个 useState，Hook 的调用顺序在每次渲染中都是相同的，所以它能够正常工作。只要 Hook 的调用顺序在多次渲染之间保持一致，React就能正确地将内部 state 和对应的 Hook 进行关联</p></li><li><p>ESLint 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eslint-plugin-react-hooks </span><br><span class="line"></span><br><span class="line">npm install eslint-plugin-react-hooks --save-dev</span><br><span class="line"></span><br><span class="line">yarn add eslint - plugin - react - hooks--dev</span><br></pre></td></tr></table></figure></li><li><p>自定义hook</p><ol><li>自定义 Hook 是一个函数，其名称以 ‘use’ 开头，函数内部可以调用其他的 Hook</li></ol></li></ol><h2 id="FAQ-整理"><a href="#FAQ-整理" class="headerlink" title="FAQ(整理)"></a>FAQ(整理)</h2><ol><li><p>调用 setState 是异步，若是需要确保每次调用都是使用最新的 state，需要给 setState 传递一个函数而不是一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">incrementCount()&#123;</span><br><span class="line"></span><br><span class="line">    this.setState((state) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        return &#123; count: state.count &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleSomething()&#123;</span><br><span class="line"></span><br><span class="line">    // 假设 this.state.count 从 0 开始</span><br><span class="line"></span><br><span class="line">    this.incrementCount()</span><br><span class="line"></span><br><span class="line">    this.incrementCount()</span><br><span class="line"></span><br><span class="line">    this.incrementCount()</span><br><span class="line"></span><br><span class="line">    // 如果在这里读取 this.state.count 它还是为 0</span><br><span class="line"></span><br><span class="line">    // 但是，当 React 重新渲染该组件时，它会变为 3</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​     </p><ol start="2"><li><p>目前在事件处理函数内部的 setState 是异步的</p><p><strong>注意：</strong> 调用 setState 其实时异步的，不要指望在调用 setState 之后，this.state 会立即映射新的值。如果需要基于当前的 state 来计算出新的值，应该传递一个函数，而不是一个对象</p></li><li><p>react 不同步更新 this.state原因：</p><ol><li>在开始渲染之前，React会有意地进行等待，直到所有在组件的时间处理函数内部调用的 setState() 完成之后。这样就可以通过避免不必要的重新渲染来提升细嫩那个</li><li>这样会破坏props 和 state 之间的一致性，造成一些难以 debug 的问题</li><li>这样会让一些我们正在实现的新功能变得无法实现</li></ol></li><li><p>React组件 AJAX and APIs</p><ol><li>AJAX<br> <strong>axios、jQuery ajax、window.fetch</strong></li><li>发送请求</li></ol></li></ol><p>​      建议在 componentDidMount 中发送请求更新组件的state</p><p>​  3. 注意：</p><p>​          在使用fetch请求时不能使用 catch() 来捕获错误 因为 catch 捕获异常会掩盖组件本身可能产生的 bug</p><ol start="5"><li>Virtual DOM（虚拟DOM）</li></ol><p>​    是一种编程概念。在这个概念里，UI以一种理想化的，或者说 虚拟的 表现形式被保存于内存中，并通过 ReactDom 等类库使之与真实的DOM 同步。这一过程叫做协调。与其将虚拟DOM视为一种技术，不如说它是一种模式</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ci/cd</title>
      <link href="/2022/07/06/ci-cd/"/>
      <url>/2022/07/06/ci-cd/</url>
      
        <content type="html"><![CDATA[<p>CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续继承、持续交付和持续部署。作为一个面向开发和运营 团队的解决方案，CI&#x2F;CD 主要针对在集成新代码时所引发的问题（亦称：‘集成地狱’）</p><span id="more"></span><h1 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol><li><p>CI ( <strong>持续集成</strong> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程。持续集成是启动管道的环节（尽管某些预验证 —— 通常称为上线前检查pre-flight checks —— 有时会被归在持续集成之前）</span><br><span class="line"></span><br><span class="line">持续集成的目标是快速确保开发人员新提交的变更是好的，并且适合在代码库中进一步使用</span><br></pre></td></tr></table></figure><p><strong>持续的含义</strong></p><ul><li><p>频繁发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">持续实践背后的目标是能够频繁地交付高质量的软件</span><br></pre></td></tr></table></figure></li><li><p>自动化流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现此频率的关键是用自动化流程来处理软件生产中的方方面面。这包括构建、测试、分析、版本控制，以及在某些情况下的部署</span><br></pre></td></tr></table></figure></li><li><p>可重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把某个历史版本的代码作为输入，我们应该得到对应相同的可交付产出</span><br><span class="line">理想情况下，这也意味着可以对管道中的流程进行版本控制和重建</span><br></pre></td></tr></table></figure></li><li><p>快速迭代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“快速”在这里是个相对术语，但无论软件更新/发布的频率如何，预期的持续过程都会以高效的方式将源代码转换为交付物</span><br></pre></td></tr></table></figure></li></ul><p><strong>什么是持续交付管道</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将源代码转换为可发布产品的多个不同的任务task和作业job通常串联成一个软件“管道”，一个自动流程成功完成后会启动管道中的下一个流程。这些管道有许多不同的叫法，例如持续交付管道、部署管道和软件开发管道。大体上讲，程序管理者在管道执行时管理管道各部分的定义、运行、监控和报告。</span><br></pre></td></tr></table></figure></li><li><p>CD ( <strong>持续交付</strong> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指整个流程链（管道），它自动监测源代码变更并通过构建、测试、打包和相关操作运行它们以生成可部署的版本，基本上没有任何人为干预。</span><br><span class="line"></span><br><span class="line">持续交付在软件开发过程中的目标是自动化、效率、可靠性、可重复性和质量保障（通过持续测试）。</span><br></pre></td></tr></table></figure></li><li><p>CD ( <strong>持续部署</strong> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">持续部署（CD）是指能够自动提供持续交付管道中发布版本给最终用户使用的想法。根据用户的安装方式，可能是在云环境中自动部署、app 升级（如手机上的应用程序）、更新网站或只更新可用版本列表。</span><br></pre></td></tr></table></figure></li><li><p><strong>持续测试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">持续测试是指在代码通过持续交付管道时运行扩展范围的自动化测试的实践。单元测试通常与构建过程集成，作为持续集成阶段的一部分，并专注于和其它与之交互的代码隔离的测试。</span><br></pre></td></tr></table></figure><ul><li><strong>集成测试</strong> 验证组件和服务组合在一起是否正常。</li><li><strong>功能测试</strong> 验证产品中执行功能的结果是否符合预期。</li><li><strong>验收测试</strong> 根据可接受的标准验证产品的某些特征。如性能、可伸缩性、抗压能力和容量。</li></ul></li></ol><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h3><p><a href="https://docs.gitlab.com/ee/ci/">官方</a>阶段关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.pre -&gt;build -&gt;test</span><br></pre></td></tr></table></figure><p>自定义stages</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line"> - stages 1</span><br><span class="line"> - stages 2</span><br><span class="line"> - stages 3</span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定一个基础Docker镜像作为基础运行环境</span><br></pre></td></tr></table></figure><h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定Runner,在项目中的runner中可以进行配置 runner tags</span><br></pre></td></tr></table></figure><h3 id="only-x2F-except"><a href="#only-x2F-except" class="headerlink" title="only&#x2F;except"></a>only&#x2F;except</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">限定当前任务执行的条件</span><br></pre></td></tr></table></figure><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现发生故障或尽管发生故障时仍能运行的环境</span><br><span class="line">when: manual --&gt; 手动</span><br></pre></td></tr></table></figure><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存当前工作环境目录中的一些文件,</span><br></pre></td></tr></table></figure><h3 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a>allow_failure</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="artifacts"><a href="#artifacts" class="headerlink" title="artifacts"></a><a href="https://docs.gitlab.com/ee/ci/yaml/README.html#artifacts">artifacts</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用来保存文档</span><br></pre></td></tr></table></figure><h4 id="expire-in"><a href="#expire-in" class="headerlink" title="expire_in"></a>expire_in</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置文件保存时间</span><br><span class="line">未设置时间单位默认是 秒</span><br></pre></td></tr></table></figure><h4 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要保存文件的路径</span><br></pre></td></tr></table></figure><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上传</span><br><span class="line">scp -r 递归上传</span><br></pre></td></tr></table></figure><h2 id="项目部署-阿里云oss"><a href="#项目部署-阿里云oss" class="headerlink" title="项目部署(阿里云oss)"></a>项目部署(阿里云oss)</h2><h3 id="上传服务器"><a href="#上传服务器" class="headerlink" title="上传服务器"></a>上传服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ossutil cp -r -f dist/ oss://xpanel-fast-lenovo-com-cn/bugfix/latest/dist</span><br></pre></td></tr></table></figure><h2 id="变量的注入与使用"><a href="#变量的注入与使用" class="headerlink" title="变量的注入与使用"></a>变量的注入与使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">environment:url</span><br><span class="line">environment:name</span><br><span class="line">resource_group</span><br><span class="line">include</span><br><span class="line">variables --&gt; 设置全局变量</span><br><span class="line">image</span><br><span class="line">services:[]</span><br><span class="line">service:[]:name</span><br><span class="line">cache:key</span><br><span class="line">artifacts:name</span><br><span class="line">script,before_script,after_script</span><br><span class="line">only:variables:[],except:variables:[],rules:if</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variables:</span><br><span class="line">MT:&#x27;my name&#x27;</span><br></pre></td></tr></table></figure><h1 id="CSDN文献"><a href="#CSDN文献" class="headerlink" title="CSDN文献"></a><a href="https://fizzz.blog.csdn.net/article/details/117172382">CSDN文献</a></h1><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</span><br><span class="line">Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程Docker 链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2022/07/05/webpack/"/>
      <url>/2022/07/05/webpack/</url>
      
        <content type="html"><![CDATA[<p>webpack 随手记</p><span id="more"></span><h1 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h1><h2 id="五个核心概念"><a href="#五个核心概念" class="headerlink" title="五个核心概念"></a>五个核心概念</h2><ol><li>Entry(入口)<ul><li>指示 webpack 以哪个文件为入口起点开始打包,分析构建依赖图</li></ul></li><li>Output(出口)<ul><li>指示webpack 打包后资源 bundles 输出到哪里去,以及如何命名</li></ul></li><li>Loader(‘ 翻译 ‘)<ul><li>让 webpack 能够处理那些非 Javascript文件(webpack 自身只理解 Javascript )</li></ul></li><li>Plugins<ul><li>可以用于执行范围更广的任务.插件范围包括:从打包优化和压缩一直到重新定义环境中的变量等</li></ul></li><li>Mode<ol><li>开发模式<ol><li>特点:能让代码本地测试运行的环境</li></ol></li><li>生产模式<ol><li>特点:能让代码优化上线运行的环境</li></ol></li><li><img src="https://s1.ax1x.com/2020/05/31/t33Mo6.png"></li></ol></li></ol><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>指示 webpack 应该使用哪个模块，来作为构建其<strong>内部依赖图</strong> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口七点 依赖的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">entry：&#x27;./src/index.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>告诉webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports =&#123;</span><br><span class="line">output:&#123;</span><br><span class="line">        path: 路径,</span><br><span class="line">        filename: 文件名称</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><strong>webpack 只能理解 JavaScript 和 JSON 文件</strong>，这是webpack开箱可用的自带能力。<strong>loader</strong>让 webpack 能够去处理<strong>其他类型的文件</strong>，并将它们转换为有效 <strong>模块</strong>，以供应应用程序使用，以及被添加到依赖图中。</p><p>将模块内容按照需求转化成新内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack 的其中一个强大的特性就是通过 import 导入任何类型的模块（例如： .css 文件），其他打包程序或人物执行器的可能并不支持。</span><br></pre></td></tr></table></figure><p><strong>loader 有两个属性：</strong></p><ol><li><p><strong>test</strong> 属性，识别出哪些文件会被转换。</p></li><li><p><strong>use</strong> 属性，定义出在进行转换时，应该使用哪个 loader。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">module:&#123;</span><br><span class="line">rules:[&#123;test:/.\txt$/,use:&#x27;raw-loader&#x27;&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p><p>想要使用一个插件，只需要 <strong>require（）</strong>，然后把它添加到 <strong>plugins</strong> 数组中。多数插件可以通过选项（<strong>option</strong>）自定义。也可以在<strong>一个配置文件中因为不同的目的而多次使用同一个插件</strong>，这时需要通过使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 webpack 构建流程中的特定时机会广播出对应的时间，插件可以监听这些事件的发生，在特定时机做对应的事情</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>在webpack里一切皆模块，一个模块对应着一个文件。webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>代码块，一个Chunk 由多个模块组合而成，用于代码合并与分割</p><h1 id="webpack-初体验"><a href="#webpack-初体验" class="headerlink" title="webpack 初体验"></a>webpack 初体验</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli -g | -D(开发依赖)</span><br><span class="line"></span><br><span class="line">开发环境 : webpack ./src/index.js -o  ./build/built.js --mode-development ./src/index.js 为入口文件开始打包,打包后输出到 ./build/built.js  -- 整体打包环境是开发环境</span><br><span class="line">webpack 会以</span><br><span class="line"></span><br><span class="line">生产环境打包 : webpack ./src/index.js -o  ./build/built.js --mode-production</span><br></pre></td></tr></table></figure><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src - index.js 入口文件</span><br><span class="line">build - 打包文件的地方</span><br></pre></td></tr></table></figure><ol><li>webpack 能处理 js &#x2F; json 资源,不能处理 css &#x2F;img 等其他资源</li><li>生产环境比开发环境多一个压缩 js 代码</li><li>生产和开发环境 将ES6模块化编译成浏览器能识别的模块化</li></ol><h2 id="webpack打包资源"><a href="#webpack打包资源" class="headerlink" title="webpack打包资源"></a>webpack打包资源</h2><h3 id="样式打包"><a href="#样式打包" class="headerlink" title="样式打包"></a>样式打包</h3><p>lader必须定义配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">webpack.confug.js -- webpack的配置文件</span><br><span class="line">指示webpack 干什么(当运行 webpack 指令时,会加载里面的配置)</span><br><span class="line">所有的构建工具都是基于 node.js 平台运行的~模块化默认采用 commjs</span><br><span class="line">commjs暴露模式</span><br><span class="line"></span><br><span class="line">resolve用来拼接绝对路径的方法</span><br><span class="line">const &#123;resolve&#125; = require(&#x27;path&#x27;)</span><br><span class="line">const HtmlWebpack = requie</span><br><span class="line">module.exports = &#123;</span><br><span class="line">entry:&#x27;./src/index.js&#x27; ~入口七点</span><br><span class="line">output:&#123;</span><br><span class="line">filename:&quot;&quot; 输出文件名</span><br><span class="line">path: resole(_dirname,&#x27;build&#x27;)~输出路径 / _dirname代表当前文件的目录的绝对路径</span><br><span class="line">&#125;,</span><br><span class="line">module:&#123;</span><br><span class="line">rules:[</span><br><span class="line">详细loader配置</span><br><span class="line">&#123;</span><br><span class="line">                test:/\.css$/,</span><br><span class="line">                //use数组中 loader 执行顺序:从右到左,从上到下,依次执行</span><br><span class="line">                use:[ 使用哪些loader进行处理</span><br><span class="line">                    &#x27;style-loader&#x27;</span><br><span class="line">                    &#x27;css-loader&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; 排除 css html js 文件</span><br><span class="line">exclude:/\.(css|html|js)$/</span><br><span class="line">loader:&#x27;file - loader&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">处理图片资源</span><br><span class="line">&#123;</span><br><span class="line">test:/\.(jpg|png|gif)$/</span><br><span class="line">loader:&#x27;url-loader&#x27;,</span><br><span class="line">options:&#123;</span><br><span class="line">limit:8*1024,</span><br><span class="line">name:&#x27;[hash:10.[ext]]&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//处理html中 img 资源</span><br><span class="line">test:/\.html$/,</span><br><span class="line">loader:&#x27;html-loader&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">详细plugins的配置</span><br><span class="line">new HtmlWebpack(&#123;</span><br><span class="line">template:&#x27;./src/index.html&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">],</span><br><span class="line">模式</span><br><span class="line">mode:&#x27;development&#x27; / &#x27;production&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="devServe"><a href="#devServe" class="headerlink" title="devServe"></a>devServe</h3><p>自动编译,在内存中进行打包,不会有任何输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">contenBase:resolve(_dirname,&#x27;build&#x27;),</span><br><span class="line">//开启压缩</span><br><span class="line">compress:true,</span><br><span class="line">port:3000,</span><br><span class="line">//自动打开浏览器</span><br><span class="line">open:true</span><br><span class="line">&#125;</span><br><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><h1 id="webpack开发环境搭建"><a href="#webpack开发环境搭建" class="headerlink" title="webpack开发环境搭建"></a>webpack开发环境搭建</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">entry:&#x27;&#x27;,</span><br><span class="line">output:&#123;</span><br><span class="line">filename:&#x27;built.js&#x27;</span><br><span class="line">path: </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码的集合就是开发环境搭建</span><br></pre></td></tr></table></figure><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol><li><p>工作原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析项目结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言（Sass、TypeScript等），并将其转换和打包为合适的格式供浏览器使用</span><br></pre></td></tr></table></figure></li><li><p>打包原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一切都视为模块： 不管是 css、js、image 还是 html 都可以互相引用，通过定义 entry.</span><br></pre></td></tr></table></figure></li><li><p>如何提高webpack 构建速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonsChunkPlugin</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/07/05/TypeScript/"/>
      <url>/2022/07/05/TypeScript/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 知识点随手记</p><span id="more"></span><h1 id="认识TS"><a href="#认识TS" class="headerlink" title="认识TS"></a>认识TS</h1><p>是js的一个超集,提供了类型系统和ES6+ 的支持,不能直接被浏览器运行的.ts中的json文件可以写<strong>注释</strong>,默认是严格模式</p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>自动编译TS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc --init  项目中的根目录下</span><br><span class="line">修改config.js文件</span><br></pre></td></tr></table></figure><p>使用webpack打包TS</p><p>下载依赖</p><p><img src="https://s1.ax1x.com/2020/06/10/t7m9sI.png"></p><p><strong>cross-env</strong>指定生产环境或开发环境的一个包(包括 windows + linux 系统)</p><p>创建 <strong>webpack.config.js</strong> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV === &#x27;production&#x27; 是否生产环境的一个判断</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="TS的基础数据类型"><a href="#TS的基础数据类型" class="headerlink" title="TS的基础数据类型"></a>TS的基础数据类型</h1><ol><li><p>布尔</p></li><li><p>number</p></li><li><p>string</p></li><li><p>null  undefined</p><ol><li>元素的属性只能是 null + undefined</li></ol></li><li><p>数组</p><ol><li><p>数组的类型</p><ul><li><p>类型+方括号 表示法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let f:number[] = [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li><li><p>数组中<strong>不允许</strong>出现其他的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let f:number[] = [1,2,&quot;1&quot;,3,4]</span><br><span class="line">// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure></li><li><p>数组的一些方法参数会根据数组在定义时约定的类型进行限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let f:number[] = [1,2,3,1,4];</span><br><span class="line">f.push(&#x27;8&#x27;)</span><br><span class="line">// Argument of type &#x27;&quot;8&quot;&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><ul><li>上面数组中定义只允许传入数字类型的参数,传入了’8’(字符串类型),所以报错</li></ul></li></ul></li><li><p>数组的泛型(Array<elemType>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fib:Array&lt;number&gt; = [1,1,2,3,4]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元组(Tuple)</p><ol><li><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let t: [number,string]</span><br><span class="line">t = [1,&#x27;abc&#x27;]</span><br><span class="line">t = [&#x27;abc&#x27;,1] -&gt; 报错 类型不匹配</span><br></pre></td></tr></table></figure></li></ol></li><li><p>枚举</p><ol><li><p>对JavaScript标准数据类型的一个补充,使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">red,</span><br><span class="line">yellow,</span><br><span class="line">blue</span><br><span class="line">&#125;</span><br><span class="line">let color: Color = Color.red</span><br><span class="line">根据名称取对应保存的数值</span><br><span class="line">根据数值读取对应的名称</span><br></pre></td></tr></table></figure></li></ol></li><li><p>any</p><ol><li><p>在编程阶段声明的变量类型是不确定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let notShure :any = 1</span><br></pre></td></tr></table></figure></li><li><p>在数组中的应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用any表示数组中允许出现任意类型</span><br><span class="line">let list:any[] = [&#x27;kevin&#x27;,20,&#123;website:&#x27;http://www.baidu.com&#x27;&#125;]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>void</p><ol><li>与any类型相反,代表函数的返回值只能是 undefined 或者 null</li></ol></li><li><p>Never</p></li><li><p>表示的是那些永不存在的值的类型</p></li><li><p>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。即使 any 也不可以赋值给never</p></li><li><p>object</p><ol><li><p>表示非原始类型,也就是 number,string,boolean 之外的类型</p></li><li><p>使用 object 类型,就可以更好的表示像 Object.creat这样的 API</p></li></ol></li><li><p>联合类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求1:定义一个函数得到一个数字或字符串值的字符串形式值</span><br><span class="line">(()=&gt;&#123;</span><br><span class="line">functon toString</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>类型断言</p></li><li><p>类型推断</p></li></ol><h1 id="TS接口"><a href="#TS接口" class="headerlink" title="TS接口"></a>TS接口</h1><p>TS的核心原则之一是对值所具有的结构进行类型检查.使用接口来定义对象的类型.接口时对象的状态(属性)和行为(方法)的抽象(描述)</p><ol><li><p>接口( <strong>interface</strong> )规范</p><ul><li><p>readonly -&gt; 只读属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readonly id:number  id属性为只读的,不可以进行二次赋值</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数类型的接口</p><ul><li><p>创建一个函数类型的变量并赋值给这个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch:searchFunc</span><br><span class="line">mySearch = function(source:string,subString:string)&#123;</span><br><span class="line">let result source.search(subString);</span><br><span class="line">return result &gt; -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于函数类型的类型检查来说,函数的参数名不需要与接口里定义的名字相匹配</li><li>函数的参数会逐个检查,要求对应位置上的参数类型的兼容,如果不想指定类型,ts类型系统会推断出参数类型.如果让这个函数返回数字或字符串,类型检查器会警告函数的返回值类型与 <strong>SearchFunc</strong> 接口中的定义不匹配</li></ol></li></ul></li></ol><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><ol><li><p>类实现接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface test &#123;</span><br><span class="line">current:Date;</span><br><span class="line">&#125;</span><br><span class="line">class Clock implements test&#123;</span><br><span class="line">current:Date;</span><br><span class="line">setTime(d:Date)&#123;</span><br><span class="line">this.current = d;</span><br><span class="line">&#125;</span><br><span class="line">constructor(h:number,m:number)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类实现继承(<strong>extends</strong>)</p></li><li><p>类的基本定义与使用</p></li><li><p>类的继承_方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">class animal&#123;</span><br><span class="line">run(distance:number)&#123;</span><br><span class="line">console.log(`animal run $&#123;distance&#125;m `)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类</span><br><span class="line">class dog extend animal&#123;</span><br><span class="line">//重写从父类继承的方法</span><br><span class="line">super.run(distance)</span><br><span class="line">&#125;</span><br><span class="line">const dog = new dog()</span><br><span class="line">dog.run(10)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多态_父类型引用指向子类型对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个类只能继承一个单一的类</span><br><span class="line">多态:父类型的引用指向子类型的实例</span><br></pre></td></tr></table></figure></li></ol><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><ol><li><p>类数组不是数组类型,比如 <strong>arguments</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line">let args:number[] = arguments;</span><br><span class="line">&#125;</span><br><span class="line">报错// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span><br></pre></td></tr></table></figure><p>argumen实际上是一个类数组,不能用普通数组的方式来描述,应该使用接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line">let args:&#123;</span><br><span class="line">[index:number]:number;</span><br><span class="line">length:number;</span><br><span class="line">callee:Function;</span><br><span class="line">&#125; = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">a:string;</span><br><span class="line">constructor(message:string)&#123;</span><br><span class="line">this.a = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get()&#123;</span><br><span class="line">return &#x27;hello,&#x27;+ this.a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new test(&#x27;world&#x27;);</span><br><span class="line">console.log(b) // hello,world</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    move(distanceInMeters: number = 0) &#123;</span><br><span class="line">        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        console.log(&#x27;Woof! Woof!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认是 public(公共的)</span><br><span class="line"></span><br><span class="line">private(私有的)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="/2022/07/05/Vue/"/>
      <url>/2022/07/05/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>全家桶：</strong> vue-cli、vueRouter、vuex、axios</p><span id="more"></span><h1 id="Vue核心思想"><a href="#Vue核心思想" class="headerlink" title="Vue核心思想"></a>Vue核心思想</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面拆分</span><br></pre></td></tr></table></figure><hr><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><ol><li><strong>数据驱动是vue双向数据绑定的灵魂</strong><ol><li>当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的修改dom</li></ol></li><li><strong>vuejs实现数据驱动原理</strong><ol><li>采用数据劫持结合<strong>发布者-订阅模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。当把一个普通的js对象传给Vue实例作为他的 data 选项时，Vue会便利它的属性，用<strong>Object.defineProperty（）</strong>将他们转为 getter&#x2F;setter。</li><li>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {undefined{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</li></ol></li><li><strong>对getter&#x2F;setter的理解</strong><ol><li>get取值，set赋值</li><li>如何知道对象的值做了更改？<ol><li>当调用属性时会进入get属性中，先判断是否有这个属性，如果没有就添加一个name属性，并给他赋值；如果有name属性则返回name属性。值的改变都必须经过set，其他方式是改变不了相当于是一个万能的监听器。ES5的对象原型有两个属性_defineGetter_  和 _defineSetter_，专门用来给对象绑定get和ser</li></ol></li></ol></li></ol><p><strong>Object.defineProperty</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  obj,</span><br><span class="line">  key,</span><br><span class="line">  val,</span><br><span class="line">  customSetter,</span><br><span class="line">  shallow</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 创建派发器</span></span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.<span class="property">get</span>;</span><br><span class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.<span class="property">set</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val;</span><br><span class="line">      <span class="comment">// 收集依赖对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>();</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;development&quot;</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal);</span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="MVVM-和-MVC"><a href="#MVVM-和-MVC" class="headerlink" title="MVVM 和 MVC"></a>MVVM 和 MVC</h1><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ol><li><strong>Model：</strong> 指的是数据部分，对应到前端相当于JavaScript对象</li><li><strong>View：</strong> 指的是视图部分，对应前端相当于dom</li><li><strong>ViewModel</strong>： 就是连接视图与数据的中组件通讯</li></ol><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC全名是 Model View Controller,时<strong>模型 - 视图 - 控制器</strong>的缩写，一种<strong>软件设计典范</strong>。</p><ul><li>Model(模型)：是用于处理应用程序数据逻辑部分。通常模型对象负责在数据库中存取数据。</li><li>View(视图)：是应用程序中处理数据显示的本分。通常视图是依据模型数据创建的。</li><li>Controller(控制器)：是应用程序处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p><strong>MVC的思想</strong>：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在<strong>Controller</strong>里面把<strong>Model</strong>的数据赋值给<strong>View</strong>。</p><h3 id="两者之前的区别"><a href="#两者之前的区别" class="headerlink" title="两者之前的区别"></a>两者之前的区别</h3><p>MVVM与MVC最大的区别就是：<strong>实现了View和Model的自动同步</strong>，也就是当Model的属性改变时，我们不用再手动操作Dom元素来改变View的显示。 而是改变属性后该属性对应的View层显示会自动改变（对应Vue数据驱动的思想）</p><p>整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了<strong>数据频繁更新</strong>的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也察觉不到View，这种低耦合模式提高代码的可重用性。</p><p><strong>注意</strong>：Vue并没有完全遵循MVVM的思想，这一点官网自己也有声明。</p><hr><h1 id="Vue-2-0响应式数据的原理"><a href="#Vue-2-0响应式数据的原理" class="headerlink" title="Vue 2.0响应式数据的原理"></a>Vue 2.0响应式数据的原理</h1><p><strong>整体思路：</strong> 数据劫持+观察者模式</p><p>对象内部通过 defineReactive 方法，使用Object.defineProoperty将属性进行劫持（置灰劫持已存在的属性），数组则是通过重写数组来实现。当页面谁用对应属性时，每个属性都拥有自己的 dep 属性，存在它所以来的 watch （依赖收集） get，当属性变化后会通知自己对应的 watcher 去更新（派发更新） set。</p><ol><li>object.defineProperty 数据劫持</li><li>使用 getter 手动依赖，setter 通知 watch 派发更新。</li><li>watch 发布订阅</li></ol><h1 id="Vue-3-0"><a href="#Vue-3-0" class="headerlink" title="Vue 3.0"></a>Vue 3.0</h1><ol><li><p>响应式原理的改变 Vue3.x 使用Proxy。</p></li><li><p>组件选项声明方式 Vue3.x 使用 <strong>Composition API</strong> setup是Vue3.x新增的一个选项，他是组件内使用Composition API 的入口。</p></li><li><p>模板语法变化 slot 具名插槽语法，自定义指令v-model 升级</p></li><li><p>其他方面的更改 Suspense支持Fragment（多个根节点）和 Protal（在dom其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。基于 treeShaking 优化，提供了更多的内置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">treeShaking 是一种通过清除多余代码的方式来优化项目打包体积的技术，专业术语叫 Dead code elimination；是基于  ES6 模板语法（import 与 exports），主要是借助 ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个Vue实例在被创建都要经过一系列的初始化过程 --- 例如：需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等</span><br></pre></td></tr></table></figure><p><strong>PS:</strong></p><ol><li><p><strong>beforeCreate</strong>：<strong>实例刚在内存中被创建出来</strong></p></li><li><p><strong>created</strong> 钩子可以用来在一个 <strong>实例被创建之后执行代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a is: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; &quot;a is: 1&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h1><p>组件的data写成一个函数，数据以向函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全部都会变的结果。</p><h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><p>1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。</p><p>2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。</p><p>3、$attrs 和 $listeners A -&gt; B -&gt; C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。</p><p>4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）</p><p>5、$refs 获取组件实例。</p><p>6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。</p><p>7、vuex 状态管理。</p><h2 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h2><h3 id="Vue的父子组件生命周期钩子函数执行顺序"><a href="#Vue的父子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue的父子组件生命周期钩子函数执行顺序"></a>Vue的父子组件生命周期钩子函数执行顺序</h3><ol><li><strong>加载渲染过程</strong><ul><li>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</li></ul></li><li><strong>子组件更新过程</strong><ul><li>父beforeUpdate -&gt; <strong>子</strong>beforeUpdate -&gt; <strong>子</strong>updated -&gt; 父updated</li></ul></li><li><strong>父组件更新过程</strong><ul><li>父beforeUpdate -&gt; 父updated</li></ul></li><li><strong>销毁过程</strong><ul><li>父beforeDestroy -&gt; <strong>子</strong>beforeDestroy -&gt; <strong>子</strong>destroyed -&gt; 父destroyed</li></ul></li></ol><h3 id="parent-children"><a href="#parent-children" class="headerlink" title="parent + children"></a>parent + children</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指定已创建的实例之父实例，在两者之间简历父子关系。</span><br><span class="line">子实例可以用 this.$parent 访问父实例,</span><br><span class="line">子实例被推入到父实例的 this.$childer 数组中</span><br></pre></td></tr></table></figure><h3 id="provide-x2F-inject"><a href="#provide-x2F-inject" class="headerlink" title="provide &#x2F; inject"></a>provide &#x2F; inject</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provide：Object | () =&gt; Object</span><br><span class="line">inject：Array&lt;string&gt; | &#123; [key: string]: string | Symbol | Object &#125;</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><strong>provide</strong> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property</li><li>在该对象中可以使用  <strong>Symbols</strong> 作为key，但是只在原生支持 <strong>Symbol</strong> 和 <strong>Reflect.ownKeys</strong> 的环境下可工作</li><li><strong>provide</strong> 和 <strong>inject</strong> 绑定并不是可响应的。但是如果你传入了一个 <strong>可监听的对象</strong>，那么其对象的 property还是可响应的</li></ol><h3 id="on-emit"><a href="#on-emit" class="headerlink" title="$on + $emit"></a>$on + $emit</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$on(<span class="string">&#x27;test&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="comment">// =&gt; &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><strong>父组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: [&#x27;title&#x27;],</span><br><span class="line">  template: &#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#blog-post-demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">posts</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;My journey with Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Blogging with Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;Why Vue is so fun&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p><a href="https://cn.vuejs.org/images/lifecycle.png">https://cn.vuejs.org/images/lifecycle.png</a></p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在实例初始化之后，进行数据监听和事件/监听器的配置之前同步调用</span><br><span class="line"></span><br><span class="line">实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</span><br></pre></td></tr></table></figure><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。</span><br><span class="line"></span><br><span class="line">实例已经在内存中创建🆗，此时 data 和 methods 已经创建🆗，此时还没有开始 编译模板</span><br></pre></td></tr></table></figure><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在挂载开始之前被调用：相关的 render 函数首次被调用。</span><br><span class="line">该钩子在服务器端渲染期间不被调用</span><br><span class="line"></span><br><span class="line">此时已经完成了模板的编译，但是还没有挂载到页面中</span><br></pre></td></tr></table></figure><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了</span><br><span class="line">注意：</span><br><span class="line"> mounted不会保证所有的子组件也都被挂载完成。若干是等整个视图都渲染完成再执行操作，可以在mounted中使用 vm.$nectTick</span><br><span class="line"> 该钩子在服务器端渲染期间不被调用</span><br><span class="line"></span><br><span class="line">此时，已经将编译好的模板，挂载到了页面指定的容器中显示</span><br></pre></td></tr></table></figure><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在数据发生改变后，Dom被更新之前被调用。这里适合在现有DOM 将要更新之前访问它，比如：移除手动添加的事件监听器。</span><br><span class="line"></span><br><span class="line">状态更新之前执行此函数，此时 data 中的状态值时最新的，但是界面上显示的数据还是 旧的，因为此时还没有重新渲染 DOM 节点</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用</span><br><span class="line">当这个钩子函数被调用时，组件DOM已经更新</span><br><span class="line"></span><br><span class="line">实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</span><br></pre></td></tr></table></figure><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被 keep-alive 缓存的组件激活时调用</span><br></pre></td></tr></table></figure><h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被 keep-alive 缓存的组件失活时调用</span><br></pre></td></tr></table></figure><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例销毁之前调用</span><br></pre></td></tr></table></figure><h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例销毁后调用。该钩子被调用后，对应的Vue实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也被销毁</span><br></pre></td></tr></table></figure><h2 id="父子组件生命周期"><a href="#父子组件生命周期" class="headerlink" title="父子组件生命周期"></a>父子组件生命周期</h2><h3 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeCreate -- 父created -- 父beforeMount -- 子beforeCreate -- 子created -- 子beforeMount -- 子mounted -- 父mounted</span><br></pre></td></tr></table></figure><h3 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate -- 子beforeUpdate -- 子updated -- 父updated</span><br></pre></td></tr></table></figure><h3 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate -- 父updated</span><br></pre></td></tr></table></figure><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeDestroy -- 子beforeDestroy -- 子destroyed -- f</span><br></pre></td></tr></table></figure><h2 id="异步请求在哪一步发起？"><a href="#异步请求在哪一步发起？" class="headerlink" title="异步请求在哪一步发起？"></a>异步请求在哪一步发起？</h2><ol><li>可以在钩子函数 <strong>created、beforeMount、mounted</strong> 中进行异步请求，因为在这三个钩子函数中，data已经创建，可以将服务器端返回的数据进行赋值</li><li>如果异步请求不需要依赖 DOM 推荐加载 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<ul><li>能更快获取到服务端数据，减少页面loading时间；</li><li>ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性。</li></ul></li></ol><hr><h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><ol><li>首次激活时，activated 都在mounted后</li><li>再次激活时，组件只走 <strong>activated</strong></li><li>组件失活时，<strong>均不走  beforeDestroy  和  destroyed</strong></li></ol><h3 id="使用场景和原理"><a href="#使用场景和原理" class="headerlink" title="使用场景和原理"></a>使用场景和原理</h3><p><strong>keep-alive</strong> 是Vue内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><ul><li>常用的两个属性 include&#x2F;exclude，允许组件有条件的进行缓存</li><li>两个生命周期 activated&#x2F;deactivated，用来得知当前组件是否处理活跃状态</li><li>keep-alive 运用了 <strong>LPU</strong> 算法，选择最近最久未使用的组件予以淘汰</li></ul><p><strong>扩展补充：LPU算法是什么？</strong></p><p><a href="https://imgtu.com/i/o28EjI"><img src="https://s4.ax1x.com/2021/12/08/o28EjI.png" alt="o28EjI.png" style="zoom:80%;" /></a></p><h1 id="Vue内置指令"><a href="#Vue内置指令" class="headerlink" title="Vue内置指令"></a>Vue内置指令</h1><ol><li>v-once - 定义它的元素或组件只渲染一次，包括元素或组件的所有节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。</li><li>v-cloak - 这个指令保持在元素上直到关联实例结束编译 – 解决初始化慢到页面闪动的最佳实践。</li><li>v-bind - 绑定属性，动态更新HTML元素上的属性。例如 v-bind:class。</li><li>v-on - 用于监听DOM事件。例如 v-on:click v-on:keyup</li><li>v-html - 赋值就是变量的innerHTML – 注意防止xss攻击</li><li>v-text - 更新元素的textContent</li><li>v-model - 1、在普通标签。变成value和input的语法糖，并且会处理拼音输入法的问题。2、再组件上。也是处理value和input语法糖。</li><li>v-if &#x2F; v-else &#x2F; v-else-if。可以配合template使用；在render函数里面就是三元表达式。</li><li>v-show - 使用指令来实现 – 最终会通过display来进行显示隐藏</li><li>v-for - 循环指令编译出来的结果是 -L 代表渲染列表。优先级比v-if高最好不要一起使用，尽量使用计算属性去解决。注意增加唯一key值，不要使用index作为key。</li><li>v-pre - 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度</li></ol><h1 id="Vue单向数据流"><a href="#Vue单向数据流" class="headerlink" title="Vue单向数据流"></a>Vue单向数据流</h1><p>数据总是从父组件传递给子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致应用的数据流向难以理解。</p><p><strong>注意：</strong>在子组件直接使用 v-model 绑定父组件传过来的 props 这样是不规范的写法，开发环境会报警告。如果是在要更改父组件的props 值可以在data中定义一个变量，并用props的值初始化它，之后用 $emit 来通知父组件去修改</p><h1 id="Vue实例化过程"><a href="#Vue实例化过程" class="headerlink" title="Vue实例化过程"></a>Vue实例化过程</h1><p><a href="https://imgtu.com/i/qnZOJA"><img src="https://s1.ax1x.com/2022/03/21/qnZOJA.md.png" alt="qnZOJA.md.png"></a></p><h1 id="Vue自定义指令"><a href="#Vue自定义指令" class="headerlink" title="Vue自定义指令"></a>Vue自定义指令</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定的指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册局部指令，组件中也接受一个directives</span></span><br><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h1><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.stop</span><br><span class="line">.prevent</span><br><span class="line">.capture</span><br><span class="line">.self 即事件不是从内部元素触发的</span><br><span class="line">.once</span><br><span class="line">.passive 不阻止事件的默认行为</span><br></pre></td></tr></table></figure><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure><h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br><span class="line">.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件</span><br><span class="line"></span><br><span class="line">// 鼠标按钮修饰符</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">.middle</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/07/05/JavaScript/"/>
      <url>/2022/07/05/JavaScript/</url>
      
        <content type="html"><![CDATA[<p>基础知识点随手记</p><span id="more"></span><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>是动态分布内存，大小不定也不会自动释放</strong> <strong>,栈内存</strong>中存放地址指向 <strong>堆内存中的对象</strong>.是按引用访问的。栈内存中存放的只是该对象的访问地址， 在堆内存中为这个值分配空间</p><h3 id="类型-引用数据类型"><a href="#类型-引用数据类型" class="headerlink" title="类型(引用数据类型)"></a>类型(引用数据类型)</h3><p><code>function</code> <code>Object</code> <code>Array</code></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>在内存中占据空间小、大小固定</strong>，他们的值保存在 <strong>栈空间</strong>， 是按 <strong>值</strong> 来访问</p><h3 id="类型（基本数据类型）"><a href="#类型（基本数据类型）" class="headerlink" title="类型（基本数据类型）"></a>类型（基本数据类型）</h3><p><code>Undefined | Null | Boolean | Number | String | Symbol</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object 是 JavaScript 中所有对象的父对象</span><br><span class="line">数据封装类对象：object、Array、Boolean、Number 和 String</span><br><span class="line">其他对象：Function、Arguments、Math、Date、RegExp、Er</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>为了使程序运行时占用的内存最小，通常要实现垃圾回收机制。<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈存里，随着方法的执行结束，这个方法的栈存也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本开销较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型存储在栈中，引用数据类型(对象)存储在堆中，指针放在栈中。</span><br><span class="line">　　两种类型的区别是：存储位置不同;原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储;引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能</span><br><span class="line">　　引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈(stack)：由编译器自动分配释放，存放函数的参数值，局部变量等;</span><br><span class="line"></span><br><span class="line">堆(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a的值是什么</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>,a,<span class="string">&#x27;b&#x27;</span>,b)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="keyword">var</span> m = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> n = m;</span><br><span class="line">n.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m.a 的值是什么?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m&#x27;</span>,m,<span class="string">&#x27;n&#x27;</span>,n)</span><br></pre></td></tr></table></figure><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p><strong>如何区分</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单点来说,就是假设B复制了A,当修改A时,看B是否会发生变化,如果B也跟着变了,说明这是浅拷贝,如果没变那就是深拷贝</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// demo2</span><br><span class="line">var m = &#123;a:1,b:2&#125;;</span><br><span class="line">var n = m;</span><br><span class="line">n.a = 3;</span><br><span class="line"></span><br><span class="line">// m.a 的值是什么?</span><br><span class="line">console.log(&#x27;m&#x27;,m,&#x27;n&#x27;,n)</span><br><span class="line">// 此时m.a 的值是发生变化为 3;因为 m 和 n 指向的是同一个地址,当n.a的值发生变化时,m.a的值也会发生变化</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>实现方法</strong></p><ol><li><p>采用 <strong>递归</strong> 去拷贝所有层级属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">                <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">                    objClone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=<span class="title function_">deepClone</span>(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b);</span><br></pre></td></tr></table></figure></li><li><p>通过 <strong>JSON</strong> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _obj = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line">    objClone = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(_obj)</span><br><span class="line"><span class="keyword">return</span> objClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点:无法实现对 对象中方法的深拷贝,会显示 undefined</strong></p></li><li><p>jQuery  <strong>extend</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newArray = $.<span class="title function_">extend</span>(<span class="literal">true</span>,[],array) <span class="comment">// true为深拷贝, false为浅拷贝</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://lodash.com/docs#find"><strong>lodash</strong> 函数库实现</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = _.cloneDeep(test)</span><br></pre></td></tr></table></figure></li></ol><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><strong>实现方法</strong></p><ol><li><p>for in 只循环第一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj2 = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] :&#123;&#125; <span class="comment">// 判断是否为数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        obj2[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:&#123;</span><br><span class="line">        <span class="attr">d</span>:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="title function_">simpCopy</span>(test)</span><br><span class="line">test2.<span class="property">a</span> = <span class="number">4</span></span><br><span class="line">test2.<span class="property">c</span>.<span class="property">d</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>,test,<span class="string">&#x27;test2&#x27;</span>,test2) <span class="comment">// test.a === 4; test.c.d ===5</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assgin方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">vra obj2 = <span class="title class_">Object</span>.<span class="title function_">assgin</span>(obj)</span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj&#x27;</span>,obj.<span class="property">a</span>) <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p><h2 id="创建Ajax的过程"><a href="#创建Ajax的过程" class="headerlink" title="创建Ajax的过程"></a>创建Ajax的过程</h2><ol><li><p>创建XMLHttpRequest对象（异步调用对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br></pre></td></tr></table></figure></li><li><p>创建新的Http请求（方法、URL、是否异步）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&#x27;get&#x27;,&#x27;example.php&#x27;,false)</span><br></pre></td></tr></table></figure></li><li><p>设置响应HTTP请求状态变化的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onreadystatechange事件中readyState属性等于4.响应的HTTP状态为200（ok）或者304</span><br></pre></td></tr></table></figure></li><li><p>发送http请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(data)</span><br></pre></td></tr></table></figure></li><li><p>获取异步调用返回的数据</p></li></ol><p><strong>注意：</strong></p><ol><li>页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。</li><li>同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax</li><li>尽量减少ajax请求次数</li><li>ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理</li></ol><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</span><br><span class="line">　　注意：JS没有块级作用域，若要形成块级作用域，可通过(function()&#123;｝)();立即执行的形式实现</span><br></pre></td></tr></table></figure><p><strong>作用域就是代码的执行环境</strong>，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是 <strong>栈内存</strong>。概况来说  <strong>作用域就是代码执行开辟栈内存</strong></p><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行黄静都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p><p>全局执行环境是最外围的执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示的执行环境的对象也不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的</span><br><span class="line">在 node 环境中，全局执行环境是 global 对象</span><br></pre></td></tr></table></figure><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>当代码在一个环境执行时，会创建变量对象的一个作用域链（作用域形成的链条）</p><ol><li>作用域链的前端，始终都是当前执行的代码所在环境的变量对象</li><li>作用域链的下一个对象来自于外部环境，而下一个变量对象来自于下一个外部环境，一直到全局执行黄静</li><li>全局执行环境的变量对象始终都是作用域链上的最后一个对象</li><li>挡在内部函数中，需要方位一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找，知道全局作用域。如果在某个变量对象中找到则使用该变量对象中的变量值。由于变量的查找是沿着作用域链来实现的，所以也称作用域链为 <strong>变量查找的机制</strong></li></ol><h1 id="this的理解"><a href="#this的理解" class="headerlink" title="this的理解"></a>this的理解</h1><ol><li>this总是指向函数的直接调用者（而非间接调用者）</li><li>如果有<strong>new</strong>关键字，this指向 <strong>new</strong> 出来的那个对象</li><li>this 表示当前对象的一个引用。在js中 this 会随着执行环境的改变而改变<ol><li>在方法中，this 表示该方法所属的对象。</li><li>如果单独使用，this 表示全局对象。</li><li>在函数中，this 表示全局对象。</li><li>在函数中，在严格模式下，this 是未定义的(undefined)。</li><li>在事件中，this 表示接收事件的元素。</li><li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li></ol></li></ol><h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如此层层递进，就构成了实例与原型的链条。这就是所谓的<strong>原型链</strong>的基本概念。</p><h1 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h1><p><strong>相同点：</strong></p><ol><li>三者都是用来改变函数的this对象的指向的</li><li>三者第一个参数都是this要指向的对象，也就是想指定的上下文</li><li>三者都可以利用后续参数传参</li><li>三者的参数不限定 string类型，允许是各种类型，包括函数、object等</li></ol><p><strong>区别：</strong></p><ol><li><p>bind 是返回对应函数，便于稍后调用；apply、call则是立即调用。bind 返回的是一个新的函数，必须调用才会执行</p></li><li><p>回调执行使用 bind 方法，立即执行使用 apply&#x2F;call</p></li><li><p>传参不同</p><ol><li>call 的参数是直接放进去，第二个及第n个参数全部都用<strong>逗号分隔</strong></li><li>apply的参数都必须放在一个<strong>数组</strong>里面</li><li>bind 参数和call 一样，但是返回的是函数</li></ol></li></ol><h1 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。所有属性和方法都是公用的，因此子类可直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。</p><p><strong>继承的方式</strong></p><p>JavaScript中的继承机制并不是明确规定的，而是通过模仿实现的。这意味着所有的继承细节并非完全由解释程序处理。作为开发者，有权决定最适用的继承方式</p><h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><p><strong>原理：</strong></p><p>​构造函数使用this关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。应为构造函数只是一个函数，所以可使 Class A 构造函数称为 Class B的方法，然后调用它。class B 就会收到ClassA 的构造函数中定义的属性和方法</p><p><strong>实现：</strong></p><p>​关键字 <strong>this</strong> 引用的是构造函数当前创建的对象。不过在这个方法中，this 指向的所属的对象。这个原理是把classA 作为常规函数来建立继承机制，而不是作为构造函数。如下使用构造函数 classB可以实现继承机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classA</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = classA;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为 classA 赋予了方法 newMethod （函数名只是指向它的指针）。然后调用该方法，传递给它的是 classB 构造函数的参数 sColor。 最后一行代码删除了对 classA 的引用，这样以后就不能再调用它</p><p><strong>注意：</strong></p><p>​所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classA</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ClassB</span>(<span class="params">sColor, sName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = <span class="title class_">ClassA</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="title class_">ClassA</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="title class_">ClassB</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.<span class="title function_">sayName</span>();<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure><h3 id="对象冒充多重继承"><a href="#对象冒充多重继承" class="headerlink" title="对象冒充多重继承"></a><strong>对象冒充多重继承</strong></h3><p>例如，如果存在两个类 ClassX 和 ClassY，ClassZ 想继承这两个类，可以使用下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClassZ</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = <span class="title class_">ClassX</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newMethod</span> = <span class="title class_">ClassY</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">newMethod</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">newMethod</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性和方法，ClassY 具有高优先级。因为它从后面的类继承。除了这点小问题之外，用对象冒充继承机制轻而易举</p><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>call()方法与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(sPrefix + <span class="variable language_">this</span>.<span class="property">color</span> + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.<span class="title function_">call</span>(obj, <span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>);</span><br><span class="line"><span class="comment">// The color is blue, a very nice color indeed.</span></span><br></pre></td></tr></table></figure><p>要与继承机制的对象冒充方法一起使用该方法，只需要将前三行的赋值、调用和删除代码替换即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor,sName</span>)&#123;</span><br><span class="line">    classA.<span class="title function_">call</span>(<span class="variable language_">this</span>,sColor);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">classA</span>(<span class="params">sColor</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h2><p>apply（）方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(sPrefix + <span class="variable language_">this</span>.<span class="property">color</span> + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.<span class="title function_">apply</span>(obj, <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>));</span><br></pre></td></tr></table></figure><p>该方法也用于替换前三行的赋值、调用和删除新方法的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor,sName</span>)&#123;</span><br><span class="line">    classA.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="keyword">new</span> <span class="title class_">Array</span>(sColor));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，第一个参数仍是 this，第二个参数只是只有一个值 color 的数组，可以把 classB 的整个 argumens 对象作为第二个参数传递给 apply（）方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classB</span>(<span class="params">sColor,sName</span>)&#123;</span><br><span class="line">    classA.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClassA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ClassB</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">objA.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">objB.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">objB.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">objA.<span class="title function_">sayColor</span>();</span><br><span class="line">objB.<span class="title function_">sayColor</span>();</span><br><span class="line">objB.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure><h2 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClassA</span>(<span class="params">sColor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = sColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassA</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayColor</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ClassB</span>(<span class="params">sColor, sName</span>) &#123;</span><br><span class="line">    <span class="title class_">ClassA</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, sColor);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = sName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">ClassB</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="title class_">ClassA</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="title class_">ClassB</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.<span class="title function_">sayColor</span>();<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.<span class="title function_">sayName</span>();<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure><h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>node js 是 commonJS 规范的主要实践者</p><p>提供支持：module、exports、require、global</p><p>实际使用时，使用 module.exports 定义当前模块对外输出的接口（不推荐直接使用 exports），用require 加载模块</p><p><strong>注意：</strong></p><p>​commonJS 用<strong>同步的方式加载模块</strong>。<strong>在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</strong></p><p>Webpack <strong>不支持</strong>使用 commonjs 模块来完成 tree-shaking。</p><h2 id="AMD-和-require-js"><a href="#AMD-和-require-js" class="headerlink" title="AMD 和 require.js"></a>AMD 和 require.js</h2><p>AMD 规范采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。JavaScript 库 require.js 实现了 AMD 规范的模块化：用 <code>require.config()</code> 指定引用路径等，用 <code>define()</code> 定义模块，用 <code>require()</code> 加载模块。</p><h2 id="CMD-和-sea-js"><a href="#CMD-和-sea-js" class="headerlink" title="CMD 和 sea.js"></a>CMD 和 sea.js</h2><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：<strong>AMD 推崇依赖前置、提前执行,在定义模块的时候就要声明其依赖的模块</strong>，<strong>CMD推崇依赖就近、延迟执行，只有在用到某个模块的时候再去require</strong>，此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) &#123;      </span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块    </span></span><br><span class="line">    a.<span class="title function_">doSomething</span>(); </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;        </span><br><span class="line">    <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了        </span></span><br><span class="line">    b.<span class="title function_">doSomething</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">/** CMD写法 **/</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;    </span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); </span><br><span class="line">    <span class="comment">//在需要时申明    </span></span><br><span class="line">    a.<span class="title function_">doSomething</span>();    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;        </span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);        </span><br><span class="line">        b.<span class="title function_">doSomething</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 </span></span><br><span class="line">math.<span class="title function_">jsdefine</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;    </span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);    </span><br><span class="line">    <span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;        </span><br><span class="line">        <span class="keyword">return</span> a+b;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">add</span> = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.<span class="title function_">use</span>([<span class="string">&#x27;math.js&#x27;</span>], <span class="keyword">function</span>(<span class="params">math</span>)&#123;    </span><br><span class="line">    <span class="keyword">var</span> sum = math.<span class="title function_">add</span>(<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ES5-Module"><a href="#ES5-Module" class="headerlink" title="ES5 Module"></a>ES5 Module</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default </span><br><span class="line">import xx from xx</span><br></pre></td></tr></table></figure><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><h3 id="3-其他总结"><a href="#3-其他总结" class="headerlink" title="3. 其他总结"></a>3. 其他总结</h3><ol><li>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li><li>ES6 的 module 是同步还是异步的？异步的。CommonJS 不支持异步</li><li>ESModule 既然是编译时加载，那可以做到运行时加载吗？（webpack 有动态import 方式）</li><li>ES6 module 语法是静态的，CommonJS 语法是动态的</li><li>ES6 module 作为新的规范，可以替代之前的 AMD、CMD、CommonJS 作为浏览器和服务端的通用模块方案</li></ol><h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p><strong>特点</strong></p><ol><li>存在服务器端</li><li>默认session的存储在服务器的 <strong>内存</strong> 中，每当一个新客户端发来请求，服务器都会开辟一个新的空间</li><li>cookie一般会配合session使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/07/04/git%E5%88%86%E6%94%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/04/git%E5%88%86%E6%94%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add xxx 或 .  --&gt; 将工作区的文件添加到暂存区(暂时保存,即将交给git进行版本管理)</span><br><span class="line">git commit -m &#x27;&#x27; / git commit -m [xxx] --&gt; &#x27;提交信息&#x27; 将暂存区的文件添加到版本</span><br><span class="line">git status 红色表示在工作区/绿色表示在暂存区</span><br><span class="line">git reset --soft HEAD^ --&gt; 撤回commit(保存修改)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff --&gt; 比较暂存区与工作区</span><br><span class="line">git diff --cached --&gt; 比较版本区与暂存区</span><br><span class="line">git diff master --&gt; 比较版本区与工作区</span><br><span class="line"></span><br><span class="line">git diff branch1 branch2 --&gt; 显示出两个分支之间所有有差异的文件的详细差异</span><br><span class="line">git diff branch1 branch2 --start --&gt; 显示两个分支之间所有有差异的文件列表</span><br><span class="line">git diff branch1 branch2 xxx --&gt; 显示指定文件的详细差异</span><br></pre></td></tr></table></figure><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git log --&gt; 显示从最近到最u按的所有提交日志,如果出现 &#x27;:&#x27; 表示为输出完成,出现end后最后完成</span><br><span class="line">git reflog --&gt; 显示每次提交(commit)的 commit id</span><br><span class="line">git reset --hard HEAD^ --&gt; 版本回退(回退一次提交),^^表示回退两次 - 最多回退两次</span><br><span class="line">git reset --hard 版本号 --&gt; 回退到指定版本号的commit id 版本</span><br><span class="line">git reset --soft 版本号 --&gt; 回退到指定版本号的commit id 并暂存修改后的文件</span><br><span class="line"></span><br><span class="line">git reset HEAD --&gt; 用版本库中的文件去替换暂存区的全部文件</span><br><span class="line">git checkout --x.txt --&gt; 用暂存区指定的文件去替换工作区的指定文件(危险操作)</span><br><span class="line">git checkout HEAD x.txt --&gt; 用版本库中的文件替换暂存区和工作区的文件(危险操作)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm x.txt --&gt; 删除文件</span><br><span class="line">git rm -r xxx --&gt; 删除文件夹</span><br><span class="line">git rm --cached x.txt --&gt;从暂存区删除文件</span><br></pre></td></tr></table></figure><h2 id="分支相关指令"><a href="#分支相关指令" class="headerlink" title="分支相关指令"></a>分支相关指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git fetch origin xxx:xxx  --拉取 &#x27;分支&#x27;（目标分支）并在本地创建 xxx 分支</span><br><span class="line"></span><br><span class="line">git checkout xxx --&gt; 切换xxx分支</span><br><span class="line">git checkout -b dev --&gt; 创建dev分支,并切换到dev分支</span><br><span class="line">git checkout -b xxx origin/xxx --&gt;拉取远程分支并在本地创建该分支</span><br><span class="line"></span><br><span class="line">git branch --&gt; 查看当前分支</span><br><span class="line">git branch -r --&gt; 查看远程所有分支</span><br><span class="line">git branch xxx --&gt; 创建xxx分支</span><br><span class="line">git branch -D branchName --&gt; 删除本地指定分支</span><br><span class="line"></span><br><span class="line">git push origin -d branchName --&gt; 删除远程指定分支</span><br><span class="line">git merge xxx --&gt; 合并xxx分支到当前分支</span><br><span class="line"></span><br><span class="line">git commit --amend --&gt; 修改最新的一次提交commit</span><br><span class="line">i --&gt; 进入修改模式</span><br><span class="line">Esc --&gt; 退出编辑模式</span><br><span class="line">:wq --&gt;  保存并退出</span><br></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog --&gt; 查看本地记录</span><br><span class="line">git rebase -i xxx  --&gt;合并commit</span><br><span class="line">i --&gt; 插入</span><br><span class="line">:wq --&gt; 保存退出</span><br></pre></td></tr></table></figure><h3 id="gitk-–all"><a href="#gitk-–all" class="headerlink" title="gitk –all"></a>gitk –all</h3><ul><li>查看 git 分支提交线</li></ul><h1 id="Git密码操作"><a href="#Git密码操作" class="headerlink" title="Git密码操作"></a>Git密码操作</h1><p>记住密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper wincred</span><br></pre></td></tr></table></figure><p>清空本地密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git credential-manager uninstall</span><br></pre></td></tr></table></figure><p>保存新密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制面板 -&gt; 用户账户 -&gt; 凭据管理器 -&gt; 普通凭据 -&gt; git:https://github.com -&gt; 编辑</span><br></pre></td></tr></table></figure><h1 id="Git-项目操作流程"><a href="#Git-项目操作流程" class="headerlink" title="Git 项目操作流程"></a>Git 项目操作流程</h1><p><img src="https://s1.ax1x.com/2020/06/17/NZVWP1.png"></p><p>远程有修改,拉取本地操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master  --&gt; 拉取到本地  -第1种</span><br><span class="line">git fetch origin master:tmp --&gt; 新建一个tmp分支,将远程仓库的master分支代码版本复制到tmp分支上,不会自动合并  -第2种</span><br></pre></td></tr></table></figure><p>克隆到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &#x27;仓库地址&#x27;  --&gt;目前只有一个分支</span><br><span class="line">git checkout -b &#x27;本地分支&#x27; origin/&#x27;远程分支&#x27; --&gt;根据远程分支来创建本地另一个分支</span><br><span class="line">git pull --&gt;拉取远程仓库的全部东西</span><br><span class="line">Octotree --&gt;GitHub管理器(chrome插件)</span><br></pre></td></tr></table></figure><h2 id="协作开发"><a href="#协作开发" class="headerlink" title="协作开发"></a>协作开发</h2><ol><li>GitHub官网 –&gt; New organization(创建团队&#x2F;组织)</li><li>选择free 或者其他</li><li>输入组织名称&#x2F;联系邮箱</li><li>进行权限配置</li><li>创建新的仓库 -&gt;私有化</li><li>添加成员,添加成员的账户名或者邮箱</li><li>对成员进行权限的配置(读&#x2F;写&#x2F;管理员)</li><li>发送邀请,成员同意</li></ol><h2 id="合并分支-差异对比"><a href="#合并分支-差异对比" class="headerlink" title="合并分支(差异对比)"></a>合并分支(差异对比)</h2><ol><li><p>远程分支有更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --&gt; 将远程分支拉取到本地,并在本地新建一个与远程分支名字一样的本地分支</span><br><span class="line">git fetch origin xxx远程分支名 --&gt;拉取xxx远程分支变为本地分支</span><br></pre></td></tr></table></figure></li><li><p>从远程分支拉取到本地分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch 本地分支名  --&gt; 新建本地分支</span><br><span class="line">git pull origin xxx远程分支名  --&gt; 拉取远程分支的代码到新建的本地分支</span><br></pre></td></tr></table></figure></li><li><p>建立本地分支与远程分支的跟踪联系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1- git branch -vv --&gt; 可以查看本地分支对应的远程分支</span><br><span class="line"></span><br><span class="line">git checkout -b dev origin/dev --&gt; 在远程分支的基础上建立dev分支,并且让dev分支追踪origin/branch-name</span><br><span class="line"></span><br><span class="line">2- git分支追踪远程分支</span><br><span class="line"></span><br><span class="line">git branch --set-upstream test origin/master --&gt;建立本地仓test并建立追踪关系,如果建立了本地仓也建立了追踪会修改追踪关系(建议使用)</span><br><span class="line">git branck --track test origin/develop</span><br><span class="line"></span><br><span class="line">3- 修改追踪关系,切换到test</span><br><span class="line">git checkout test</span><br><span class="line">git branch --sett-upstream-to origin/master</span><br></pre></td></tr></table></figure></li><li><p>git合并远程拉取的分支与本地修改的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 先使用 git stash 暂存本地修改的部分</span><br><span class="line">2- 再使用 git pull 拉取到远程分支</span><br><span class="line">3- 使用 git stash pop 弹出本地修改部分,此时git会自动合并</span><br></pre></td></tr></table></figure></li></ol><h1 id="GitFork"><a href="#GitFork" class="headerlink" title="GitFork"></a>GitFork</h1><ol><li><pre><code>git clone 地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   git remote add upstream 地址(将b项目作为最新代码的参考标准 -- upstream 是上有仓库的别名,别名可随意命名)</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>在本地更改代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   git add . </span><br><span class="line">   git stash 暂存本地代码</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>拉取远程代码git pull / git fetch upstream</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
